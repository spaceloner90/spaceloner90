<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid of Elements</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap">
    <style>
        /* Apply border-box sizing to all elements for more predictable layouts */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the contenteditable fields to give user feedback */
        [contenteditable]:focus {
            outline: none;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        [contenteditable] {
            cursor: text;
        }
        /* CSS to create placeholder text for the name field */
        [data-placeholder]:empty::before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.6); /* Lighter color for hint text */
            pointer-events: none; /* Allow clicks to focus the element */
        }
        /* Visual feedback for the item being dragged */
        .dragging {
            opacity: 0.5;
            border: 2px dashed #60a5fa; /* A blue dash to stand out */
        }
        /* Make items draggable and add base transition */
        .draggable {
            cursor: grab;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative; 
        }
        .draggable:active {
            cursor: grabbing;
        }
        /* Apply hover effect ONLY to non-highlighted items */
        .draggable:not(.highlighted):hover {
            transform: translateY(-4px);
        }

        /* --- Animation for the Highlight --- */
        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.3);
            }
            100% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
        }

        /* --- New Animation for Pop-in Effect --- */
        @keyframes pop-in {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .pop-in-animation {
            animation: pop-in 0.3s ease-out forwards;
        }

        /* Style for the highlighted/selected item */
        .highlighted {
            transform: scale(1.05) translateY(-8px); /* Slightly larger and more lifted */
            animation: pulse-border 1.5s infinite; /* Apply the new animation */
        }
        
        /* New style for highlighting selected statuses in the modal */
        .symbol-selected {
            background-color: #dbeafe; /* A light blue background */
            border: 2px solid #60a5fa; /* A slightly darker blue border */
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- Main container for the scene -->
    <div class="w-full max-w-6xl mx-auto px-4 py-8">

        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Vick's Initiative Tracker</h1>

        <!-- Container for the elements, now a wrapping flex container -->
        <div id="shelf-items" class="flex flex-wrap justify-center items-start gap-4 min-h-80 p-4 bg-white rounded-lg shadow-inner">
            
            <!-- The Black Bar / Turn Marker -->
            <div class="draggable bg-black rounded-full w-2 h-56 shadow-lg self-center"></div>

            <!-- Elements will be populated by JavaScript -->
        </div>

        <!-- Button Container -->
        <div class="mt-8 text-center space-y-4">
            <div class="space-x-4">
                <button id="move-item-btn" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                    Next Turn (SPACE)
                </button>
                 <button id="last-turn-btn" class="bg-amber-500 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-amber-600 focus:outline-none focus:ring-4 focus:ring-amber-300 transition-all duration-200">
                    Last Turn (BACKSPACE)
                </button>
                <button id="add-item-btn" class="bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-200">
                    Add Character (A)
                </button>
            </div>
            <!-- Second row of buttons for actions on highlighted items -->
            <div id="action-buttons" class="space-x-4">
                <button id="remove-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Remove (DELETE)
                </button>
                <button id="copy-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Copy (C)
                </button>
                <button id="add-status-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Add Status (S)
                </button>
                <button id="clear-statuses-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Clear Statuses (X)
                </button>
            </div>
        </div>
    </div>

    <!-- Status Symbol Modal -->
    <div id="status-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-800">Select a Status Effect</h2>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <div id="symbol-grid" class="grid grid-cols-5 gap-4">
                <!-- Symbols will be populated here by JavaScript -->
            </div>
        </div>
    </div>


    <!-- JavaScript Logic -->
    <script>
        // Get the buttons and containers
        const lastTurnButton = document.getElementById('last-turn-btn');
        const moveButton = document.getElementById('move-item-btn');
        const addButton = document.getElementById('add-item-btn');
        const removeButton = document.getElementById('remove-btn');
        const copyButton = document.getElementById('copy-btn');
        const addStatusButton = document.getElementById('add-status-btn');
        const clearStatusesButton = document.getElementById('clear-statuses-btn');
        const shelf = document.getElementById('shelf-items');
        const statusModal = document.getElementById('status-modal');
        const closeModalButton = document.getElementById('close-modal-btn');
        const symbolGrid = document.getElementById('symbol-grid');

        // --- Data ---
        const colorPalette = [
            'bg-red-500', 'bg-orange-500', 'bg-amber-500', 'bg-lime-500', 
            'bg-green-500', 'bg-cyan-500', 'bg-sky-500', 'bg-indigo-500',
            'bg-purple-500', 'bg-fuchsia-500', 'bg-pink-500', 'bg-rose-500'
        ];
        let colorIndex = 0;
        
        const statusSymbols = ['☠️', '🔥', '❄️', '⚡️', '🛡️', '⚔️', '❤️‍🩹', '😵', '🤢', '❓', '💪', '🎯'];

        // --- Core Functions for Item States ---

        function updateActionButtonsState() {
            const selectedItem = document.querySelector('.highlighted');
            const buttonsToUpdate = [removeButton, copyButton, addStatusButton, clearStatusesButton];
            
            if (selectedItem) {
                buttonsToUpdate.forEach(button => {
                    button.disabled = false;
                    button.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                });
                removeButton.classList.add('bg-red-600', 'hover:bg-red-700', 'focus:ring-4', 'focus:ring-red-300');
                copyButton.classList.add('bg-teal-600', 'hover:bg-teal-700', 'focus:ring-4', 'focus:ring-teal-300');
                addStatusButton.classList.add('bg-purple-600', 'hover:bg-purple-700', 'focus:ring-4', 'focus:ring-purple-300');
                clearStatusesButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-4', 'focus:ring-yellow-300');

            } else {
                buttonsToUpdate.forEach(button => {
                    button.disabled = true;
                    button.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                    button.classList.remove(
                        'bg-red-600', 'hover:bg-red-700', 'focus:ring-red-300',
                        'bg-teal-600', 'hover:bg-teal-700', 'focus:ring-teal-300',
                        'bg-purple-600', 'hover:bg-purple-700', 'focus:ring-purple-300',
                        'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-300',
                        'focus:ring-4'
                    );
                });
            }
        }

        function initializeDraggable(item) {
            item.setAttribute('draggable', true);
            item.addEventListener('dragstart', () => setTimeout(() => item.classList.add('dragging'), 0));
            item.addEventListener('dragend', () => item.classList.remove('dragging'));
        }

        function initializeSelectable(item) {
            // Can't select the turn marker bar
            if (item.querySelectorAll('span').length === 0) return;

            item.addEventListener('click', (event) => {
                const isClickOnIcon = event.target.tagName === 'SPAN' && event.target.parentElement.classList.contains('status-container');
                
                if (event.target.getAttribute('contenteditable') === 'true' || isClickOnIcon) {
                    return;
                }

                const isAlreadySelected = item.classList.contains('highlighted');
                document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                
                if (!isAlreadySelected) {
                    item.classList.add('highlighted');
                }
                
                updateActionButtonsState();
            });
        }

        function initializeHpField(hpSpan) {
            // Store the original value on focus
            hpSpan.addEventListener('focus', () => {
                hpSpan.dataset.originalHp = hpSpan.textContent.trim();
            });

            // This function resolves the expression
            const resolveHp = () => {
                const originalHp = parseInt(hpSpan.dataset.originalHp, 10);
                const expression = hpSpan.textContent.trim();

                if (isNaN(originalHp)) return; // Failsafe

                let newHp;
                
                try {
                    // Use a regex to ensure the expression only contains safe characters.
                    const validExpressionRegex = /^[0-9+\-\s]+$/;
                    if (!validExpressionRegex.test(expression)) {
                        throw new Error("Invalid characters in expression");
                    }
                    
                    const numbers = expression.match(/[+\-]?\s*\d+/g);
                    
                    if (!numbers) {
                        throw new Error("No numbers found in expression");
                    }

                    const result = numbers.reduce((total, numStr) => {
                        return total + parseInt(numStr.replace(/\s/g, ''), 10);
                    }, 0);

                    newHp = result;

                } catch (error) {
                    console.error("HP calculation error:", error);
                    newHp = originalHp;
                }
                
                hpSpan.textContent = newHp;
            };
            
            hpSpan.addEventListener('blur', resolveHp);

            hpSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    resolveHp();
                    hpSpan.blur();
                } else if (e.key === 'Escape') {
                    hpSpan.textContent = hpSpan.dataset.originalHp;
                    hpSpan.blur();
                }
            });
        }
        
        document.querySelectorAll('.draggable').forEach(item => {
            initializeDraggable(item);
            initializeSelectable(item);
        });

        // --- Drag & Drop Logic ---
        shelf.addEventListener('dragover', e => {
            e.preventDefault();
            const draggingItem = document.querySelector('.dragging');
            if (!draggingItem) return;
            const afterElement = getDragAfterElement(shelf, e.clientX);
            if (afterElement == null) {
                shelf.appendChild(draggingItem);
            } else {
                shelf.insertBefore(draggingItem, afterElement);
            }
        });

        function getDragAfterElement(container, x) {
            const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- Character Creation ---
        function createCharacter(name, hp, statuses = []) {
            const newItem = document.createElement('div');
            const newColor = colorPalette[colorIndex++ % colorPalette.length];
            newItem.className = `draggable ${newColor} rounded-md w-32 min-h-56 shadow-lg flex flex-col justify-between p-2 text-white`;
            
            const nameContent = name ? name : '';
            const namePlaceholder = name ? '' : 'data-placeholder="Name"';

            newItem.innerHTML = `
                <div class="flex flex-col items-center flex-shrink-0">
                    <span contenteditable="true" class="font-bold text-lg p-1 text-center" ${namePlaceholder}>${nameContent}</span>
                    <div class="flex flex-col items-center mt-2">
                        <span class="text-xs font-semibold text-white/80 select-none">HP</span>
                        <span contenteditable="true" class="text-2xl font-mono p-1">${hp}</span>
                    </div>
                </div>
                <div class="status-container w-full flex-grow mt-2 p-1 flex flex-wrap items-center justify-center content-start gap-2">
                </div>
            `;

            const statusContainer = newItem.querySelector('.status-container');
            statuses.forEach(symbol => {
                 const statusIcon = document.createElement('span');
                 statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-pointer";
                 statusIcon.textContent = symbol;
                 statusIcon.addEventListener('click', () => statusIcon.remove());
                 statusContainer.appendChild(statusIcon);
            });
            
            const hpSpan = newItem.querySelector('.text-2xl.font-mono');
            initializeHpField(hpSpan);

            initializeDraggable(newItem);
            initializeSelectable(newItem);
            
            // Add to DOM and then animate
            shelf.appendChild(newItem);
            newItem.classList.add('pop-in-animation');
            newItem.addEventListener('animationend', () => {
                newItem.classList.remove('pop-in-animation');
            }, { once: true });
        }

        // --- Modal Logic ---
        function populateSymbolModal(selectedItem) {
            symbolGrid.innerHTML = '';
            
            // Get currently applied statuses for the selected character
            const statusContainer = selectedItem.querySelector('.status-container');
            const appliedIcons = statusContainer.querySelectorAll('span');
            const appliedStatuses = new Set(Array.from(appliedIcons).map(icon => icon.textContent));

            statusSymbols.forEach((symbol, index) => {
                const symbolButton = document.createElement('button');
                symbolButton.className = "relative text-3xl p-4 rounded-lg hover:bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500";
                
                // Highlight the button if the status is already applied
                if (appliedStatuses.has(symbol)) {
                    symbolButton.classList.add('symbol-selected');
                }

                const displayNumber = (index + 1) % 10;
                
                symbolButton.innerHTML = `
                    <span class="pointer-events-none">${symbol}</span>
                    <span class="absolute bottom-1 right-1 text-xs font-mono bg-gray-600 text-white rounded-sm px-1.5 py-0.5 pointer-events-none">${displayNumber}</span>
                `;
                
                symbolButton.addEventListener('click', () => {
                    symbolButton.classList.toggle('symbol-selected'); // Toggle highlight immediately

                    const existingIcons = statusContainer.querySelectorAll('span');
                    let existingIcon = null;
                    existingIcons.forEach(icon => {
                        if (icon.textContent === symbol) {
                            existingIcon = icon;
                        }
                    });

                    if (existingIcon) {
                        // If it exists, remove it from the character card
                        existingIcon.remove();
                    } else {
                        // If it doesn't exist, add it to the character card
                        const statusIcon = document.createElement('span');
                        statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-pointer";
                        statusIcon.textContent = symbol;
                        statusIcon.addEventListener('click', () => statusIcon.remove());
                        statusContainer.appendChild(statusIcon);
                    }
                });
                symbolGrid.appendChild(symbolButton);
            });
        }
        
        function handleStatusModalToggle() {
             if (!statusModal.classList.contains('hidden')) {
                statusModal.classList.add('hidden');
            } else {
                if (!addStatusButton.disabled) {
                    const selectedItem = document.querySelector('.highlighted');
                    if (selectedItem) {
                        populateSymbolModal(selectedItem); // Repopulate based on current selection
                        statusModal.classList.remove('hidden');
                    }
                }
            }
        }

        addStatusButton.addEventListener('click', handleStatusModalToggle);
        closeModalButton.addEventListener('click', () => statusModal.classList.add('hidden'));
        statusModal.addEventListener('click', (e) => {
             if (e.target.id === 'status-modal') {
                  statusModal.classList.add('hidden');
             }
        });
        
        // --- Button & Keyboard Logic ---
        lastTurnButton.addEventListener('click', () => {
            const lastItem = shelf.querySelector('.draggable:last-child');
            if(lastItem) shelf.insertBefore(lastItem, shelf.firstChild);
        });

        moveButton.addEventListener('click', () => {
            const firstItem = shelf.querySelector('.draggable');
            if(firstItem) shelf.appendChild(firstItem);
        });

        addButton.addEventListener('click', () => createCharacter('', 10));

        removeButton.addEventListener('click', () => {
            const selectedItem = document.querySelector('.highlighted');
            if (selectedItem) {
                selectedItem.remove();
                updateActionButtonsState();
            }
        });

        copyButton.addEventListener('click', () => {
            const original = document.querySelector('.highlighted');
            if (original) {
                const originalName = original.querySelector('.font-bold.text-lg').textContent.trim();
                const clone = original.cloneNode(true);
                clone.classList.remove('highlighted');
                let insertionPoint = original; // Default insertion point

                if (originalName === '') {
                    // Case 1: Name is empty. Do nothing to the name. Insert after original.
                } else {
                    // Case 2: Name is not empty. Proceed with numbering and sorting logic.
                    const allNameSpans = document.querySelectorAll('#shelf-items .font-bold.text-lg');
                    const allNames = Array.from(allNameSpans).map(span => span.textContent.trim());
                    let newName;

                    const getNextName = (currentName) => {
                        const match = currentName.match(/(.+) (\d+)$/);
                        if (match && match[1] && match[2]) {
                            const baseName = match[1];
                            const number = parseInt(match[2], 10);
                            return `${baseName} ${number + 1}`;
                        } else {
                            return `${currentName} 2`;
                        }
                    };

                    newName = getNextName(originalName);
                    while (allNames.includes(newName)) {
                        newName = getNextName(newName);
                    }
                    
                    clone.querySelector('.font-bold.text-lg').textContent = newName;

                    // Find the correct insertion point
                    const newNameMatch = newName.match(/(.+) (\d+)$/);
                    if (newNameMatch) {
                        const baseName = newNameMatch[1];
                        const newNumber = parseInt(newNameMatch[2], 10);
                        let highestFoundNumber = -1;
                        let elementToInsertAfter = null;

                        allNameSpans.forEach(span => {
                            const name = span.textContent.trim();
                            const siblingMatch = name.match(/(.+) (\d+)$/);
                            if (siblingMatch && siblingMatch[1] === baseName) {
                                const siblingNumber = parseInt(siblingMatch[2], 10);
                                if (siblingNumber < newNumber && siblingNumber > highestFoundNumber) {
                                    highestFoundNumber = siblingNumber;
                                    elementToInsertAfter = span.closest('.draggable');
                                }
                            }
                        });
                        
                        if (elementToInsertAfter) {
                            insertionPoint = elementToInsertAfter;
                        }
                    }
                }
                
                insertionPoint.after(clone);
                
                // Add pop-in animation
                clone.classList.add('pop-in-animation');
                clone.addEventListener('animationend', () => {
                    clone.classList.remove('pop-in-animation');
                }, { once: true });

                // Initialize clone's functionality
                initializeDraggable(clone);
                initializeSelectable(clone);
                const hpSpanClone = clone.querySelector('.text-2xl.font-mono');
                initializeHpField(hpSpanClone);
                clone.querySelectorAll('.status-container span').forEach(icon => {
                    icon.addEventListener('click', () => icon.remove());
                });
            }
        });

        clearStatusesButton.addEventListener('click', () => {
             const selectedItem = document.querySelector('.highlighted');
             if(selectedItem) {
                 const statusContainer = selectedItem.querySelector('.status-container');
                 if(statusContainer) {
                     statusContainer.innerHTML = '';
                 }
             }
        });
        
        document.addEventListener('keydown', (event) => {
            const activeElement = document.activeElement;
            if (activeElement.getAttribute('contenteditable') === 'true') {
                 return;
            }
            
            if (!statusModal.classList.contains('hidden') && event.code.startsWith('Digit')) {
                 event.preventDefault();
                 const keyNumber = event.code === 'Digit0' ? 9 : parseInt(event.code.slice(-1)) - 1;
                 const symbolButtons = symbolGrid.querySelectorAll('button');
                 if (symbolButtons[keyNumber]) {
                     symbolButtons[keyNumber].click();
                 }
                 return;
            }

            switch (event.code) {
                case 'Space': event.preventDefault(); moveButton.click(); break;
                case 'Backspace': event.preventDefault(); lastTurnButton.click(); break;
                case 'KeyA': addButton.click(); break;
                case 'KeyS':
                    event.preventDefault();
                    handleStatusModalToggle();
                    break;
                case 'KeyC':
                    event.preventDefault();
                    if (!copyButton.disabled) copyButton.click();
                    break;
                case 'KeyX':
                    event.preventDefault();
                    if (!clearStatusesButton.disabled) clearStatusesButton.click();
                    break;
                case 'Delete':
                    event.preventDefault();
                    if (!removeButton.disabled) removeButton.click();
                    break;
                case 'Escape':
                    if (!statusModal.classList.contains('hidden')) {
                         statusModal.classList.add('hidden');
                    }
                    break;
            }
        });
        
        // --- Initial Scene Setup ---
        function initializeDefaultScene() {
            createCharacter('Goblin 1', 7);
            createCharacter('Goblin 2', 7);
            createCharacter('Goblin 3', 2, ['❤️‍🩹']);
            createCharacter('Hector the Well-Endowed', 18, ['⚡️']);
        }
        
        // populateSymbolModal(); // No longer needed here
        initializeDefaultScene();

    </script>

</body>
</html>
