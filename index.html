<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid of Elements</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap">
    <style>
        /* Apply border-box sizing to all elements for more predictable layouts */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            user-select: none; /* Prevent text selection during drag operations */
        }
        /* Style for the contenteditable fields to give user feedback */
        [contenteditable]:focus {
            outline: none;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        [contenteditable] {
            cursor: text;
            user-select: text; /* Allow text selection inside editable fields */
        }
        /* CSS to create placeholder text for the name field */
        [data-placeholder]:empty::before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.6); /* Lighter color for hint text */
            pointer-events: none; /* Allow clicks to focus the element */
        }
        /* Visual feedback for the item being dragged */
        .dragging {
            opacity: 0.5;
            border: 2px dashed #60a5fa; /* A blue dash to stand out */
        }
        /* Make items draggable and add base transition */
        .draggable {
            cursor: grab;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative; 
        }
        .draggable:active {
            cursor: grabbing;
        }
        /* Apply hover effect ONLY to non-highlighted items */
        .draggable:not(.highlighted):hover {
            transform: translateY(-4px);
        }

        /* --- Animation for the Highlight --- */
        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.3);
            }
            100% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
        }

        /* --- New Animation for Pop-in Effect --- */
        @keyframes pop-in {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .pop-in-animation {
            animation: pop-in 0.3s ease-out forwards;
        }

        /* Style for the highlighted/selected item */
        .highlighted {
            transform: scale(1.05) translateY(-8px); /* Slightly larger and more lifted */
            animation: pulse-border 1.5s infinite; /* Apply the new animation */
        }
        
        /* New style for highlighting selected statuses in the modal */
        .symbol-selected {
            background-color: #dbeafe; /* A light blue background */
            border: 2px solid #60a5fa; /* A slightly darker blue border */
        }

        /* Style for the drag-to-select box */
        #selection-box {
            position: absolute;
            border: 2px solid #60a5fa;
            background-color: rgba(59, 130, 246, 0.2);
            pointer-events: none; /* So it doesn't interfere with mouse events */
            z-index: 9999;
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- This div is for the drag-to-select feature -->
    <div id="selection-box" style="display: none;"></div>

    <!-- Main container for the scene -->
    <div class="w-full max-w-6xl mx-auto px-4 py-8">

        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Vick's Initiative Tracker</h1>

        <!-- Container for the elements, now a wrapping flex container -->
        <div id="shelf-items" class="flex flex-wrap justify-center items-start gap-4 min-h-80 p-4 bg-white rounded-lg shadow-inner">
            
            <!-- The Black Bar / Turn Marker -->
            <div class="draggable bg-black rounded-full w-2 h-56 shadow-lg self-center"></div>

            <!-- Elements will be populated by JavaScript -->
        </div>

        <!-- Button Container -->
        <div class="mt-8 text-center space-y-4">
            <div class="space-x-4">
                <button id="move-item-btn" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                    Next Turn (SPACE)
                </button>
                 <button id="last-turn-btn" class="bg-amber-500 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-amber-600 focus:outline-none focus:ring-4 focus:ring-amber-300 transition-all duration-200">
                    Last Turn (BACKSPACE)
                </button>
                <button id="add-item-btn" class="bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-200">
                    Add Character (A)
                </button>
            </div>
            <!-- Second row of buttons for actions on highlighted items -->
            <div id="action-buttons" class="space-x-4">
                <button id="remove-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Remove (DELETE)
                </button>
                <button id="copy-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Copy (C)
                </button>
                <button id="add-status-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Add Status (S)
                </button>
                <button id="clear-statuses-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Clear Statuses (X)
                </button>
            </div>
        </div>
    </div>

    <!-- Status Symbol Modal -->
    <div id="status-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-800">Select a Status Effect</h2>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <div id="symbol-grid" class="grid grid-cols-5 gap-4">
                <!-- Symbols will be populated here by JavaScript -->
            </div>
        </div>
    </div>


    <!-- JavaScript Logic -->
    <script>
        // Get the buttons and containers
        const lastTurnButton = document.getElementById('last-turn-btn');
        const moveButton = document.getElementById('move-item-btn');
        const addButton = document.getElementById('add-item-btn');
        const removeButton = document.getElementById('remove-btn');
        const copyButton = document.getElementById('copy-btn');
        const addStatusButton = document.getElementById('add-status-btn');
        const clearStatusesButton = document.getElementById('clear-statuses-btn');
        const shelf = document.getElementById('shelf-items');
        const statusModal = document.getElementById('status-modal');
        const closeModalButton = document.getElementById('close-modal-btn');
        const symbolGrid = document.getElementById('symbol-grid');
        const selectionBox = document.getElementById('selection-box');

        // --- Data ---
        const colorPalette = [
            'bg-red-500', 'bg-orange-500', 'bg-amber-500', 'bg-lime-500', 
            'bg-green-500', 'bg-cyan-500', 'bg-sky-500', 'bg-indigo-500',
            'bg-purple-500', 'bg-fuchsia-500', 'bg-pink-500', 'bg-rose-500'
        ];
        let colorIndex = 0;
        
        const statusSymbols = ['☠️', '🔥', '❄️', '⚡️', '🛡️', '⚔️', '❤️‍🩹', '😵', '🤢', '❓', '💪', '🎯'];

        // --- Core Functions for Item States ---

        function updateActionButtonsState() {
            const selectedItems = document.querySelectorAll('.highlighted');
            const buttonsToUpdate = [removeButton, copyButton, addStatusButton, clearStatusesButton];
            
            if (selectedItems.length > 0) {
                buttonsToUpdate.forEach(button => {
                    button.disabled = false;
                    button.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                });
                removeButton.classList.add('bg-red-600', 'hover:bg-red-700', 'focus:ring-4', 'focus:ring-red-300');
                copyButton.classList.add('bg-teal-600', 'hover:bg-teal-700', 'focus:ring-4', 'focus:ring-teal-300');
                addStatusButton.classList.add('bg-purple-600', 'hover:bg-purple-700', 'focus:ring-4', 'focus:ring-purple-300');
                clearStatusesButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-4', 'focus:ring-yellow-300');

            } else {
                buttonsToUpdate.forEach(button => {
                    button.disabled = true;
                    button.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                    button.classList.remove(
                        'bg-red-600', 'hover:bg-red-700', 'focus:ring-red-300',
                        'bg-teal-600', 'hover:bg-teal-700', 'focus:ring-teal-300',
                        'bg-purple-600', 'hover:bg-purple-700', 'focus:ring-purple-300',
                        'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-300',
                        'focus:ring-4'
                    );
                });
            }
        }

        function initializeDraggable(item) {
            item.setAttribute('draggable', true);
            item.addEventListener('dragstart', () => {
                if (!item.classList.contains('highlighted')) {
                    document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                    item.classList.add('highlighted');
                }
                setTimeout(() => item.classList.add('dragging'), 0)
            });
            item.addEventListener('dragend', () => item.classList.remove('dragging'));
        }

        function initializeSelectable(item) {
            if (item.querySelectorAll('span').length === 0) return;

            item.addEventListener('click', (event) => {
                const isClickOnIcon = event.target.tagName === 'SPAN' && event.target.parentElement.classList.contains('status-container');
                if (event.target.getAttribute('contenteditable') === 'true' || isClickOnIcon) return;
                
                if (event.shiftKey) {
                    item.classList.toggle('highlighted');
                } else {
                    const isAlreadySelected = item.classList.contains('highlighted');
                    const selectedCount = document.querySelectorAll('.highlighted').length;

                    if (isAlreadySelected && selectedCount > 1) return;
                    
                    document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                    if (!isAlreadySelected) item.classList.add('highlighted');
                }
                updateActionButtonsState();
            });
        }

        function initializeHpField(hpSpan) {
            hpSpan.addEventListener('focus', () => {
                hpSpan.dataset.originalHp = hpSpan.textContent.trim();
            });

            const resolveHp = () => {
                const originalHp = parseInt(hpSpan.dataset.originalHp, 10);
                const expression = hpSpan.textContent.trim();
                if (isNaN(originalHp)) return;

                let newHp;
                try {
                    const validExpressionRegex = /^[0-9+\-\s]+$/;
                    if (!validExpressionRegex.test(expression)) throw new Error("Invalid characters");
                    const numbers = expression.match(/[+\-]?\s*\d+/g);
                    if (!numbers) throw new Error("No numbers found");
                    newHp = numbers.reduce((total, numStr) => total + parseInt(numStr.replace(/\s/g, '')), 0);
                } catch (error) {
                    console.error("HP calculation error:", error);
                    newHp = originalHp;
                }
                hpSpan.textContent = newHp;
            };
            
            hpSpan.addEventListener('blur', resolveHp);
            hpSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); resolveHp(); hpSpan.blur(); } 
                else if (e.key === 'Escape') { hpSpan.textContent = hpSpan.dataset.originalHp; hpSpan.blur(); }
            });
        }
        
        document.querySelectorAll('.draggable').forEach(item => {
            initializeDraggable(item);
            initializeSelectable(item);
        });

        shelf.addEventListener('dragover', e => {
            e.preventDefault();
            const draggingItem = document.querySelector('.dragging');
            if (!draggingItem) return;
            const afterElement = getDragAfterElement(shelf, e.clientX);
            if (afterElement == null) shelf.appendChild(draggingItem);
            else shelf.insertBefore(draggingItem, afterElement);
        });

        function getDragAfterElement(container, x) {
            const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
                else return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function createCharacter(name, hp, statuses = [], insertionElement = null) {
            const newItem = document.createElement('div');
            const newColor = colorPalette[colorIndex++ % colorPalette.length];
            newItem.className = `draggable ${newColor} rounded-md w-32 min-h-56 shadow-lg flex flex-col justify-between p-2 text-white`;
            
            const nameContent = name || '';
            const namePlaceholder = name ? '' : 'data-placeholder="Name"';

            newItem.innerHTML = `
                <div class="flex flex-col items-center flex-shrink-0">
                    <span contenteditable="true" class="font-bold text-lg p-1 text-center" ${namePlaceholder}>${nameContent}</span>
                    <div class="flex flex-col items-center mt-2">
                        <span class="text-xs font-semibold text-white/80 select-none">HP</span>
                        <span contenteditable="true" class="text-2xl font-mono p-1">${hp}</span>
                    </div>
                </div>
                <div class="status-container w-full flex-grow mt-2 p-1 flex flex-wrap items-center justify-center content-start gap-2"></div>`;

            const statusContainer = newItem.querySelector('.status-container');
            statuses.forEach(symbol => {
                 const statusIcon = document.createElement('span');
                 statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-pointer";
                 statusIcon.textContent = symbol;
                 statusIcon.addEventListener('click', () => statusIcon.remove());
                 statusContainer.appendChild(statusIcon);
            });
            
            initializeHpField(newItem.querySelector('.text-2xl.font-mono'));
            initializeDraggable(newItem);
            initializeSelectable(newItem);
            
            if(insertionElement) insertionElement.after(newItem);
            else shelf.appendChild(newItem);

            newItem.classList.add('pop-in-animation');
            newItem.addEventListener('animationend', () => newItem.classList.remove('pop-in-animation'), { once: true });
        }

        // --- Modal Logic ---
        function populateSymbolModal(selectedItems) {
            symbolGrid.innerHTML = '';
            
            statusSymbols.forEach((symbol, index) => {
                const symbolButton = document.createElement('button');
                symbolButton.className = "relative text-3xl p-4 rounded-lg hover:bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500";
                
                const allHaveStatus = selectedItems.length > 0 && Array.from(selectedItems).every(item => {
                    const appliedStatuses = Array.from(item.querySelectorAll('.status-container span')).map(s => s.textContent);
                    return appliedStatuses.includes(symbol);
                });
                
                if (allHaveStatus) symbolButton.classList.add('symbol-selected');

                const displayNumber = (index + 1) % 10;
                symbolButton.innerHTML = `<span class="pointer-events-none">${symbol}</span><span class="absolute bottom-1 right-1 text-xs font-mono bg-gray-600 text-white rounded-sm px-1.5 py-0.5 pointer-events-none">${displayNumber}</span>`;
                
                symbolButton.addEventListener('click', () => {
                    // Decide action based on state *before* the click
                    if (allHaveStatus) {
                        // If all have it, remove from all
                        selectedItems.forEach(item => {
                            item.querySelectorAll('.status-container span').forEach(icon => {
                                if (icon.textContent === symbol) icon.remove();
                            });
                        });
                        symbolButton.classList.remove('symbol-selected');
                    } else {
                        // If some/none have it, add to all
                        selectedItems.forEach(item => {
                            const appliedStatuses = Array.from(item.querySelectorAll('.status-container span')).map(s => s.textContent);
                            if (!appliedStatuses.includes(symbol)) {
                                const statusIcon = document.createElement('span');
                                statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-pointer";
                                statusIcon.textContent = symbol;
                                statusIcon.addEventListener('click', () => statusIcon.remove());
                                item.querySelector('.status-container').appendChild(statusIcon);
                            }
                        });
                        // After adding to all, the button should appear selected
                        symbolButton.classList.add('symbol-selected');
                    }
                    // Repopulate to correctly reflect the new state for the next click
                    populateSymbolModal(selectedItems);
                });
                symbolGrid.appendChild(symbolButton);
            });
        }
        
        function handleStatusModalToggle() {
             if (!statusModal.classList.contains('hidden')) {
                statusModal.classList.add('hidden');
            } else {
                if (!addStatusButton.disabled) {
                    const selectedItems = document.querySelectorAll('.highlighted');
                    if (selectedItems.length > 0) {
                        populateSymbolModal(selectedItems);
                        statusModal.classList.remove('hidden');
                    }
                }
            }
        }

        addStatusButton.addEventListener('click', handleStatusModalToggle);
        closeModalButton.addEventListener('click', () => statusModal.classList.add('hidden'));
        statusModal.addEventListener('click', (e) => {
             if (e.target.id === 'status-modal') statusModal.classList.add('hidden');
        });
        
        // --- Button & Keyboard Logic ---
        lastTurnButton.addEventListener('click', () => {
            const lastItem = shelf.querySelector('.draggable:last-child');
            if(lastItem) shelf.insertBefore(lastItem, shelf.firstChild);
        });

        moveButton.addEventListener('click', () => {
            const firstItem = shelf.querySelector('.draggable');
            if(firstItem) shelf.appendChild(firstItem);
        });

        addButton.addEventListener('click', () => createCharacter('', 10));

        removeButton.addEventListener('click', () => {
            document.querySelectorAll('.highlighted').forEach(item => item.remove());
            updateActionButtonsState();
        });

        copyButton.addEventListener('click', () => {
            const originals = document.querySelectorAll('.highlighted');
            if (originals.length > 0) {
                let allNames = new Set(Array.from(document.querySelectorAll('#shelf-items .font-bold.text-lg')).map(span => span.textContent.trim()));
                originals.forEach(original => {
                    const originalName = original.querySelector('.font-bold.text-lg').textContent.trim();
                    const hp = original.querySelector('.text-2xl.font-mono').textContent.trim();
                    const statuses = Array.from(original.querySelectorAll('.status-container span')).map(s => s.textContent);
                    let newName = originalName;
                    
                    if (originalName !== '') {
                        const getNextName = (currentName) => {
                            const match = currentName.match(/(.+) (\d+)$/);
                            return match ? `${match[1]} ${parseInt(match[2], 10) + 1}` : `${currentName} 2`;
                        };
                        let nextName = getNextName(originalName);
                        while (allNames.has(nextName)) nextName = getNextName(nextName);
                        newName = nextName;
                        allNames.add(newName);
                    }
                    createCharacter(newName, hp, statuses, original);
                });
            }
        });

        clearStatusesButton.addEventListener('click', () => {
             document.querySelectorAll('.highlighted').forEach(item => {
                 const statusContainer = item.querySelector('.status-container');
                 if(statusContainer) statusContainer.innerHTML = '';
             });
        });

        let isSelecting = false;
        let startX, startY;
        shelf.addEventListener('mousedown', (e) => {
            if (e.target !== shelf) return;
            e.preventDefault();
            isSelecting = true;
            startX = e.clientX; startY = e.clientY;
            Object.assign(selectionBox.style, { left: `${startX}px`, top: `${startY}px`, width: '0px', height: '0px', display: 'block' });
            if (!e.shiftKey) {
                document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                updateActionButtonsState();
            }
        });
        window.addEventListener('mousemove', (e) => {
            if (!isSelecting) return;
            e.preventDefault();
            const currentX = e.clientX, currentY = e.clientY;
            const width = Math.abs(currentX - startX), height = Math.abs(currentY - startY);
            const left = Math.min(currentX, startX), top = Math.min(currentY, startY);
            Object.assign(selectionBox.style, { width: `${width}px`, height: `${height}px`, left: `${left}px`, top: `${top}px` });
            const boxRect = selectionBox.getBoundingClientRect();
            document.querySelectorAll('.draggable').forEach(item => {
                if (item.querySelectorAll('span').length === 0) return;
                const itemRect = item.getBoundingClientRect();
                const isIntersecting = !(boxRect.right < itemRect.left || boxRect.left > itemRect.right || boxRect.bottom < itemRect.top || boxRect.top > itemRect.bottom);
                if (isIntersecting) item.classList.add('highlighted');
                else if(!e.shiftKey) item.classList.remove('highlighted');
            });
            updateActionButtonsState();
        });
        window.addEventListener('mouseup', () => {
            if (isSelecting) {
                isSelecting = false;
                selectionBox.style.display = 'none';
            }
        });
        
        document.addEventListener('keydown', (event) => {
            if (document.activeElement.getAttribute('contenteditable') === 'true') return;
            
            if (!statusModal.classList.contains('hidden') && event.code.startsWith('Digit')) {
                 event.preventDefault();
                 const keyNumber = event.code === 'Digit0' ? 9 : parseInt(event.code.slice(-1)) - 1;
                 const symbolButtons = symbolGrid.querySelectorAll('button');
                 if (symbolButtons[keyNumber]) symbolButtons[keyNumber].click();
                 return;
            }

            switch (event.code) {
                case 'Space': event.preventDefault(); moveButton.click(); break;
                case 'Backspace': event.preventDefault(); lastTurnButton.click(); break;
                case 'KeyA': event.preventDefault(); addButton.click(); break;
                case 'KeyS': event.preventDefault(); handleStatusModalToggle(); break;
                case 'KeyC': event.preventDefault(); if (!copyButton.disabled) copyButton.click(); break;
                case 'KeyX': event.preventDefault(); if (!clearStatusesButton.disabled) clearStatusesButton.click(); break;
                case 'Delete': event.preventDefault(); if (!removeButton.disabled) removeButton.click(); break;
                case 'Escape':
                    if (!statusModal.classList.contains('hidden')) statusModal.classList.add('hidden');
                    else {
                        document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                        updateActionButtonsState();
                    }
                    break;
            }
        });
        
        function initializeDefaultScene() {
            createCharacter('Goblin 1', 7);
            createCharacter('Goblin 2', 7);
            createCharacter('Goblin 3', 2, ['❤️‍🩹']);
            createCharacter('Hector the Well-Endowed', 18, ['⚡️']);
        }
        
        initializeDefaultScene();
    </script>
</body>
</html>
