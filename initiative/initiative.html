<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Initiatve Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap">
    <style>
        /* Apply border-box sizing to all elements for more predictable layouts */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            user-select: none; /* Prevent text selection during drag operations */
        }
        /* Style for the contenteditable fields to give user feedback */
        [contenteditable]:focus {
            outline: none;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        [contenteditable] {
            cursor: text;
            user-select: text; /* Allow text selection inside editable fields */
        }
        /* CSS to create placeholder text for the name field */
        [data-placeholder]:empty::before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.6); /* Lighter color for hint text */
            pointer-events: none; /* Allow clicks to focus the element */
        }
        /* Visual feedback for the item being dragged */
        .dragging {
            opacity: 0.5;
            border: 2px dashed #60a5fa; /* A blue dash to stand out */
        }
        /* Make items draggable and add base transition */
        .draggable {
            cursor: grab;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            background-size: cover;
            background-position: center;
        }
        .draggable:active {
            cursor: grabbing;
        }
        /* Apply hover effect ONLY to non-highlighted items */
        .draggable:not(.highlighted):hover {
            transform: translateY(-4px);
        }

        .invisible {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-in-out;
        }

        /* --- Animation for the Highlight --- */
        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.3);
            }
            100% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
        }

        /* --- New Animation for Pop-in Effect --- */
        @keyframes pop-in {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .pop-in-animation {
            animation: pop-in 0.3s ease-out forwards;
        }

        /* Style for the highlighted/selected item */
        .highlighted {
            transform: scale(1.05) translateY(-8px); /* Slightly larger and more lifted */
            animation: pulse-border 1.5s infinite; /* Apply the new animation */
        }

        /* New style for highlighting selected statuses in the modal */
        .symbol-selected {
            background-color: #dbeafe; /* A light blue background */
            border: 2px solid #60a5fa; /* A slightly darker blue border */
        }

        /* Style for the drag-to-select box */
        #selection-box {
            position: absolute;
            border: 2px solid #60a5fa;
            background-color: rgba(59, 130, 246, 0.2);
            pointer-events: none; /* So it doesn't interfere with mouse events */
            z-index: 9999;
        }

        /* Style for the custom color context menu */
        #context-menu {
            position: absolute;
            z-index: 10000;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 8px;
            width: 200px;
        }

        /* Add a text shadow for readability over any background */
        .text-readable {
            text-shadow: 0 1px 3px rgba(0,0,0,0.6);
        }

        /* Styles for the Notes Modal's rich text editor */
        #notes-edit-content:focus {
            outline: 2px solid #3b82f6; /* Blue outline on focus */
        }
        #notes-edit-content ul {
            list-style: disc;
            margin-left: 20px;
        }
        #notes-edit-content ol {
            list-style: decimal;
            margin-left: 20px;
        }
        /* When in edit mode, hide the view div and show the textarea */
        #notes-modal.edit-mode #notes-view-content {
            display: none;
        }
        #notes-modal.edit-mode #notes-edit-content {
            display: block;
        }

        .clickable-roll {
            color: #60a5fa; /* Tailwind's blue-400 */
            text-decoration: underline;
            cursor: pointer;
            font-weight: 500;
        }
        .clickable-roll:hover {
            color: #3b82f6; /* Tailwind's blue-500 */
        }

        /* --- Compendium & Main Wrapper Styles --- */
        #main-wrapper {
            transition: padding-right 0.3s ease-in-out, padding-bottom 0.3s ease-in-out;
        }
        body.compendium-open #main-wrapper {
            padding-right: 260px;
        }

        #compendium-container {
            position: fixed;
            top: 0;
            right: -260px; /* Start off-screen */
            bottom: 0;
            width: 300px;
            z-index: 40; /* Below modals */
            transition: right 0.3s ease-in-out;
            display: flex;
            align-items: center;
        }
        body.compendium-open #compendium-container {
            right: 0;
        }
        #compendium-handle {
            width: 40px;
            height: 160px;
            background-color: #374151; /* gray-700 */
            border-top-left-radius: 1rem;
            border-bottom-left-radius: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #compendium-handle span {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #compendium-shelf {
            width: 260px;
            height: 100%;
            background-color: #e5e7eb; /* gray-200 */
            border-left: 1px solid #d1d5db; /* gray-300 */
            position: relative;
            display: flex;
            flex-direction: column;
        }

        #compendium-shelf-inner-wrapper {
            flex-grow: 1;
            position: relative;
            overflow-y: auto;
        }

        #compendium-shelf-inner {
            position: relative;
            width: 100%;
        }

        #compendium-shelf .character-card {
            position: absolute;
            left: 50%;
            transition: top 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        /* --- NEW: Log Section Styles --- */
        body.log-open #main-wrapper {
            padding-bottom: 200px; /* Height of the log shelf */
        }
        body.compendium-open #log-container {
            right: 260px; /* Width of the compendium shelf */
        }
        #log-container {
            position: fixed;
            left: 0;
            right: 0;
            bottom: -200px; /* Start hidden (height of log-shelf) */
            height: 240px; /* height of log-shelf + log-handle */
            z-index: 30; /* Below compendium */
            transition: bottom 0.3s ease-in-out, right 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        body.log-open #log-container {
            bottom: 0;
        }
        #log-handle {
            width: 160px;
            height: 40px;
            background-color: #374151; /* gray-700 */
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 -4px 6px -1px rgba(0,0,0,0.1);
        }
        #log-handle span {
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #log-shelf {
            width: 100%;
            height: 200px;
            background-color: #1f2937; /* gray-800 */
            border-top: 1px solid #4b5563; /* gray-600 */
            display: flex;
            flex-direction: column;
        }
        #log-display {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            color: white;
            font-family: monospace, monospace;
            font-size: 0.875rem; /* text-sm */
            scroll-behavior: smooth;
        }
        #log-display::-webkit-scrollbar { width: 8px; }
        #log-display::-webkit-scrollbar-track { background: #1f2937; /* gray-800 */ }
        #log-display::-webkit-scrollbar-thumb { background: #4b5563; /* gray-600 */ border-radius: 4px; }
        #log-input-wrapper {
            border-top: 1px solid #4b5563; /* gray-600 */
        }
        #log-input {
            width: 100%;
            background-color: #374151; /* gray-700 */
            color: white;
            font-family: monospace, monospace;
            padding: 0.75rem 1rem;
            outline: none;
            border: none; /* Remove border from input itself */
        }
        #log-input:focus {
             box-shadow: inset 0 0 0 2px #3b82f6; /* blue-500 ring */
        }

        /* --- Animation for the dice result text --- */
        @keyframes reveal-result-text {
            from {
                transform: scale(0.5);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .result-reveal-animation {
            animation: reveal-result-text 0.3s ease-out forwards;
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- This div is for the drag-to-select feature -->
    <div id="selection-box" style="display: none;"></div>

    <!-- Custom context menu for changing colors and images -->
    <div id="context-menu" class="invisible">
        <div class="space-y-2">
            <div>
                <label class="block text-sm font-medium text-gray-700">Image URL</label>
                <div class="mt-1 flex rounded-md shadow-sm">
                    <input type="text" id="image-url-input" class="focus:ring-indigo-500 focus:border-indigo-500 flex-1 block w-full rounded-none rounded-l-md sm:text-sm border-gray-300 p-1">
                    <button id="apply-url-btn" class="inline-flex items-center px-3 rounded-r-md border border-l-0 border-gray-300 bg-gray-50 text-gray-500 text-sm">Apply</button>
                </div>
            </div>
            <div>
                <label for="image-file-input" class="block text-sm font-medium text-gray-700">Or Upload File</label>
                <input type="file" id="image-file-input" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100"/>
            </div>
            <div class="border-t border-gray-200 pt-2">
                 <p class="text-sm font-medium text-gray-700 mb-1">Color</p>
                 <div id="color-grid" class="grid grid-cols-6 gap-2">
                    <!-- Color swatches will be populated here by JavaScript -->
                </div>
            </div>
        </div>
    </div>


    <!-- Main container for the scene -->
    <div id="main-wrapper">
        <div class="w-full max-w-6xl mx-auto px-4 py-8">
            <!-- Container for the elements, now a wrapping flex container -->
            <div id="shelf-items" class="flex flex-wrap justify-center items-start gap-4 min-h-80 p-4 bg-white rounded-lg shadow-inner">

                <!-- The Black Bar / Turn Marker is loaded dynamically -->

                <!-- Elements will be populated by JavaScript -->
            </div>

            <!-- Button Container -->
            <div id="main-button-container" class="mt-8 text-center space-y-4">
                <!-- Centered "Roll Initiatives!" button -->
                <div>
                    <button id="roll-initiatives-btn" class="bg-gradient-to-r from-purple-600 to-indigo-600 text-white font-bold py-4 px-8 rounded-lg shadow-xl hover:shadow-2xl focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all duration-300 transform hover:-translate-y-1">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block mr-2 -mt-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                        Roll Initiatives!
                    </button>
                </div>

                <!-- Main action buttons -->
                <div class="space-x-4">
                    <button id="move-item-btn" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                        Next Turn (SPACE)
                    </button>
                    <button id="last-turn-btn" class="bg-amber-500 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-amber-600 focus:outline-none focus:ring-4 focus:ring-amber-300 transition-all duration-200">
                        Last Turn (BACKSPACE)
                    </button>
                    <button id="add-item-btn" class="bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-200">
                        Add Character (A)
                    </button>
                </div>

                <!-- Contextual action buttons -->
                <div id="action-buttons" class="space-x-4">
                    <button id="remove-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                        Remove (DELETE)
                    </button>
                    <button id="copy-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                        Copy (C)
                    </button>
                    <button id="add-status-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                        Add Status (S)
                    </button>
                    <button id="clear-statuses-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                        Clear Statuses (X)
                    </button>
                    <button id="notes-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                        Notes (N)
                    </button>
                </div>
                
                <!-- Utility buttons -->
                <div class="space-x-4">
                    <button id="hide-hp-btn" class="bg-gray-600 text-white font-bold py-2 px-5 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-300 transition-all duration-200">
                        Hide HP
                    </button>
                    <button id="clear-all-data-btn" class="bg-red-800 text-white font-bold py-2 px-5 rounded-lg shadow-md hover:bg-red-900 focus:outline-none focus:ring-4 focus:ring-red-300 transition-all duration-200">
                        Clear All Data
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Compendium Shelf HTML -->
    <div id="compendium-container">
        <div id="compendium-handle">
            <span>Compendium</span>
        </div>
        <div id="compendium-shelf">
            <div class="p-2 pt-4 flex flex-col space-y-2">
                <div class="flex items-center space-x-2">
                    <label for="min-cr-input" class="text-sm font-medium text-gray-700 flex-shrink-0">Min CR/Level:</label>
                    <input type="text" id="min-cr-input" placeholder="Min" class="flex-grow p-1 rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                </div>
                <div class="flex items-center space-x-2">
                    <label for="max-cr-input" class="text-sm font-medium text-gray-700 flex-shrink-0">Max CR/Level:</label>
                    <input type="text" id="max-cr-input" placeholder="Max" class="flex-grow p-1 rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                </div>
            </div>
             <input type="text" id="compendium-search" placeholder="Search..." class="p-2 m-2 rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
             <div id="compendium-shelf-inner-wrapper">
                <div id="compendium-shelf-inner"></div>
             </div>
             <div class="p-2 border-t border-gray-300 flex space-x-2"> <!-- Added flex and space-x-2 for layout -->
                <button id="dnd5e-import-btn" class="w-full bg-blue-700 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-600">DND 5e</button>
                <!-- NEW: PF2e Import Button -->
                <button id="pf2e-import-btn" class="w-full bg-purple-700 text-white font-bold py-2 px-4 rounded-md hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-purple-600">PF2e</button>
                <button id="manage-compendium-data-btn" class="w-full bg-gray-500 text-white font-bold py-2 px-4 rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400">Manage Data</button>
             </div>
        </div>
    </div>

    <!-- NEW: Log Section HTML -->
    <div id="log-container">
        <div id="log-handle">
            <span>Log</span>
        </div>
        <div id="log-shelf">
            <div id="log-display">
                <!-- Log entries will be populated here -->
            </div>
            <!-- NEW: Wrapper for input and button -->
            <div id="log-input-wrapper" class="flex">
                <input type="text" id="log-input" class="flex-grow" placeholder="Type here and press Enter to log...">
                <button id="d20-roll-btn" class="flex-shrink-0 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 transition-colors">d20 (R)</button>
            </div>
        </div>
    </div>

    <!-- Status Symbol Modal -->
    <div id="status-modal" class="invisible fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-800">Select a Status Effect</h2>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <div id="symbol-grid" class="grid grid-cols-5 gap-4">
                <!-- Symbols will be populated here by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Notes Modal -->
    <div id="notes-modal" class="invisible fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-2xl h-full max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 id="notes-title" class="text-xl font-bold text-gray-800">Notes for...</h2>
                <div> <!-- Wrapper for buttons -->
                    <button id="notes-toggle-edit-btn" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-blue-600 focus:outline-none">Edit</button>
                    <button id="close-notes-modal-btn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-red-600 focus:outline-none ml-2">Close</button>
                </div>
            </div>
            <!-- NEW: CR/Level Input -->
            <div class="mb-4 flex items-center">
                <label for="notes-challenge-input" class="text-gray-700 font-medium mr-2 flex-shrink-0">CR/Level:</label>
                <!-- Removed disabled attribute here so it's always enabled in HTML -->
                <input type="text" id="notes-challenge-input" class="flex-grow p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-50 text-gray-800">
            </div>
            
            <!-- NEW: View Mode Container -->
            <div id="notes-view-content" class="flex-grow overflow-y-auto p-4 border border-gray-300 rounded-md bg-gray-50">
                <!-- Processed, clickable content goes here -->
            </div>

            <!-- NEW: Edit Mode Container (hidden by default) -->
            <div id="notes-edit-content" contenteditable="true" class="hidden flex-grow w-full p-2 border border-gray-300 rounded-md bg-white overflow-y-auto focus:outline-none focus:ring-2 focus:ring-blue-500"></div>
        </div>
    </div>

    <!-- Compendium Data Modal -->
    <div id="compendium-data-modal" class="invisible fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-2xl h-full max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-xl font-bold text-gray-800">Compendium Data (Import/Export)</h2>
                <button id="close-compendium-data-modal-btn" class="bg-green-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-green-600 focus:outline-none">Done</button>
            </div>
            <textarea id="compendium-data-textarea" class="flex-grow w-full p-2 border border-gray-300 rounded-md bg-gray-50 font-mono text-sm"></textarea>
        </div>
    </div>

    <!-- D20 Dice Roll Modal -->
    <div id="dice-modal" class="invisible fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <!-- Container for both the canvas and the text overlay -->
        <div id="d20-container" class="relative w-48 h-48">
            <canvas id="d20-canvas" class="absolute inset-0 w-full h-full"></canvas>
            <div id="d20-result-overlay" class="w-full h-full flex items-center justify-center text-white text-6xl font-bold text-readable pointer-events-none">
                <!-- The result will be shown here -->
            </div>
        </div>
    </div>


    <!-- JavaScript Logic -->
    <script>
        // Get the buttons and containers
        const rollInitiativesButton = document.getElementById('roll-initiatives-btn');
        const lastTurnButton = document.getElementById('last-turn-btn');
        const moveButton = document.getElementById('move-item-btn');
        const addButton = document.getElementById('add-item-btn');
        const removeButton = document.getElementById('remove-btn');
        const copyButton = document.getElementById('copy-btn');
        const addStatusButton = document.getElementById('add-status-btn');
        const clearStatusesButton = document.getElementById('clear-statuses-btn');
        const shelf = document.getElementById('shelf-items');
        const compendiumShelf = document.getElementById('compendium-shelf');
        const compendiumShelfInner = document.getElementById('compendium-shelf-inner');
        const minCrInput = document.getElementById('min-cr-input');
        const maxCrInput = document.getElementById('max-cr-input');
        const compendiumSearch = document.getElementById('compendium-search');
        const statusModal = document.getElementById('status-modal');
        const closeModalButton = document.getElementById('close-modal-btn');
        const symbolGrid = document.getElementById('symbol-grid');
        const selectionBox = document.getElementById('selection-box');
        const contextMenu = document.getElementById('context-menu');
        const colorGrid = document.getElementById('color-grid');
        const imageUrlInput = document.getElementById('image-url-input');
        const applyUrlButton = document.getElementById('apply-url-btn');
        const imageFileInput = document.getElementById('image-file-input');
        const clearAllDataButton = document.getElementById('clear-all-data-btn');
        const notesButton = document.getElementById('notes-btn');
        const notesModal = document.getElementById('notes-modal');
        const notesToggleEditBtn = document.getElementById('notes-toggle-edit-btn');
        const closeNotesModalButton = document.getElementById('close-notes-modal-btn');
        const notesTitle = document.getElementById('notes-title');
        // NEW: Reference to the challenge input in notes modal
        const notesChallengeInput = document.getElementById('notes-challenge-input');

        const hideHpButton = document.getElementById('hide-hp-btn');
        const compendiumContainer = document.getElementById('compendium-container');
        const compendiumHandle = document.getElementById('compendium-handle');
        const manageCompendiumDataBtn = document.getElementById('manage-compendium-data-btn');
        const compendiumDataModal = document.getElementById('compendium-data-modal');
        const closeCompendiumDataModalBtn = document.getElementById('close-compendium-data-modal-btn');
        const compendiumDataTextarea = document.getElementById('compendium-data-textarea');
        // Get references to the DND 5e and PF2e buttons
        const dnd5eImportBtn = document.getElementById('dnd5e-import-btn');
        const pf2eImportBtn = document.getElementById('pf2e-import-btn');
        // NEW: Get references to log elements
        const logHandle = document.getElementById('log-handle');
        const logDisplay = document.getElementById('log-display');
        const logInput = document.getElementById('log-input');
        const d20RollBtn = document.getElementById('d20-roll-btn');

        // --- Class-based Character Management ---

        const characterRegistry = new Map();

        class Character {
            constructor({ id, name, hp, totalHp, statuses, notes, initiative, initiativeBonus, bgColor, bgImageKey, challenge, parent }) {
                this.id = id || `char-${crypto.randomUUID()}`;
                this.name = name || '';
                this.hp = hp || 10;
                this.totalHp = totalHp || 10;
                this.statuses = statuses || [];
                this.notes = notes || '';
                this.initiative = initiative || 0;
                this.initiativeBonus = initiativeBonus || 0;
                this.bgColor = bgColor || colorPalette[colorIndex++ % colorPalette.length];
                this.bgImageKey = bgImageKey || '';
                this.challenge = challenge || '';
                this.parent = parent || shelf;
            }

            // Returns a plain object for saving and exporting
            toJSON() {
                return {
                    name: this.name,
                    hp: this.hp,
                    totalHp: this.totalHp,
                    statuses: this.statuses,
                    notes: this.notes,
                    initiative: this.initiative,
                    initiativeBonus: this.initiativeBonus,
                    bgColor: this.bgColor,
                    bgImageKey: this.bgImageKey,
                    challenge: this.challenge
                };
            }

            // Creates a new Character instance from a DOM element's ID
            static fromElement(element) {
                return characterRegistry.get(element.id);
            }

            // Updates the character's DOM representation from its data
            async render() {
                let element = document.getElementById(this.id);
                if (!element) return null;

                // --- Update Text and Data ---
                element.querySelector('.font-bold.text-lg').textContent = this.name;
                element.querySelector('.current-hp').textContent = this.hp;
                element.querySelector('.total-hp').textContent = this.totalHp;
                element.querySelector('.initiative-value').textContent = this.initiative;
                element.querySelector('.initiative-bonus').textContent = this.initiativeBonus;
                element.dataset.notes = this.notes;
                element.dataset.bgImageKey = this.bgImageKey;
                element.dataset.challenge = this.challenge; // Ensure data-challenge is updated

                // --- Update Background Color ---
                const existingColor = Array.from(element.classList).find(cls => colorPalette.includes(cls));
                if (existingColor) element.classList.remove(existingColor);
                element.classList.add(this.bgColor);

                // --- Asynchronously handle background image rendering ---
                if (this.bgImageKey) {
                if (this.bgImageKey.startsWith('indexeddb://')) {
                    // If it's a local file, fetch the blob from the database.
                    const blob = await loadImageFromIndexedDB(this.bgImageKey);
                    if (blob) {
                        // Create a temporary URL and set the style.
                        element.style.backgroundImage = `url('${URL.createObjectURL(blob)}')`;
                    }
                } else {
                    // If it's a regular URL, just use it.
                    element.style.backgroundImage = `url('${this.bgImageKey}')`;
                }
                } else {
                // If there's no key, clear the background image.
                element.style.backgroundImage = '';
                }

                // --- Update Statuses ---
                const statusContainer = element.querySelector('.status-container');
                statusContainer.innerHTML = '';
                this.statuses.forEach(symbol => {
                const statusIcon = document.createElement('span');
                statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-default text-readable";
                statusIcon.textContent = symbol;
                statusContainer.appendChild(statusIcon);
                });

                // --- Update UI Indicators ---
                updateNotesIndicator(element);
                updateCharacterHpDisplay(element);
            }
        }

        // --- Dice Rolling Logic ---

        // Get references to the dice modal elements
        const diceModal = document.getElementById('dice-modal');

        // --- Three.js Dice Setup ---
        let scene, camera, renderer, die;
        // NEW: Simplified variables for the dice animation
        let isRolling = false;
        let isLoading = false;
        let currentRollResult = 0;
        let rollStartTime;
        const rollDuration = 1200; // Total duration of the roll in ms
        let sourceQuaternion, targetQuaternion;
        const d20Canvas = document.getElementById('d20-canvas');
        const d20ResultOverlay = document.getElementById('d20-result-overlay');
        let d20FaceQuaternions; // Will be populated dynamically

        let logInputHistory = [];
        let logHistoryIndex = -1; // -1 represents the user's current (new) input

        function easeOutCubic(x) {
            return 1 - Math.pow(1 - x, 3);
        }

        function generateFaceQuaternions(geometry) {
            const faceQuaternions = [];
            const targetVector = new THREE.Vector3(0, 0, 1); // We want the face normal to point to the camera

            const positionAttribute = geometry.getAttribute('position');
            const vertices = [];
            for (let i = 0; i < positionAttribute.count; i++) {
                const vertex = new THREE.Vector3();
                vertex.fromBufferAttribute(positionAttribute, i);
                vertices.push(vertex);
            }
            
            // An icosahedron has 20 faces, each defined by 3 vertices.
            for (let i = 0; i < vertices.length; i += 3) {
                const v1 = vertices[i];
                const v2 = vertices[i+1];
                const v3 = vertices[i+2];

                // Calculate the normal vector for the face
                const face = new THREE.Plane().setFromCoplanarPoints(v1, v2, v3);
                const normal = face.normal;
                
                // Calculate the quaternion that rotates the face's normal to our target vector
                const quaternion = new THREE.Quaternion().setFromUnitVectors(normal, targetVector);
                faceQuaternions.push(quaternion);
            }
            return faceQuaternions;
        }

        function init3DDice() {
            // 1. Scene
            scene = new THREE.Scene();

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, d20Canvas.clientWidth / d20Canvas.clientHeight, 0.1, 1000);
            camera.position.z = 1.7; // Smaller = closer = bigger

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ canvas: d20Canvas, alpha: true }); // alpha:true makes background transparent
            renderer.setSize(d20Canvas.clientWidth, d20Canvas.clientHeight);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.9);
            pointLight.position.set(2, 3, 4);
            scene.add(pointLight);

            // 5. Create the Die (Icosahedron for a D20)
            const geometry = new THREE.IcosahedronGeometry(1, 0); // detail 0 = sharp edges
            d20FaceQuaternions = generateFaceQuaternions(geometry);
            
            // NEW: Use a more realistic material
            const material = new THREE.MeshStandardMaterial({
                color: 0x6366f1, // Corresponds to Tailwind's indigo-500
                roughness: 0.4,
                metalness: 0.2
            });
            die = new THREE.Mesh(geometry, material);
            scene.add(die);

            // NEW: Add edges for a clearer shape
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            die.add(wireframe); // The wireframe will now rotate with the die
        }

        function animate3DDice() {
            // Keep the loop running if we are either rolling or loading.
            if (!isRolling && !isLoading) return;

            requestAnimationFrame(animate3DDice);

            if (isRolling) {
                // This is the existing logic for a normal d20 roll
                const elapsedTime = Date.now() - rollStartTime;
                let progress = elapsedTime / rollDuration;
                
                if (progress >= 1) {
                    progress = 1;
                    isRolling = false; // End the roll
                    onRollComplete(); // Trigger the completion logic
                }
                
                const easedProgress = easeOutCubic(progress);
                THREE.Quaternion.slerp(sourceQuaternion, targetQuaternion, die.quaternion, easedProgress);

            } else if (isLoading) {
                // Slower, more deliberate loading spin
                die.rotation.x += 0.02;
                die.rotation.y += 0.025;
            }

            renderer.render(scene, camera);
        }

        /**
         * Simulates a D20 roll with animation.
         * @param {number} duration - How long the rolling animation should last in milliseconds.
         */
        function rollD20() {
            isLoading = false; // Fail-safe to ensure we're not in loading mode
            diceModal.classList.remove('invisible');

            if (!scene) init3DDice();

            // Always resize renderer and camera when modal becomes visible
            const width = d20Canvas.clientWidth;
            const height = d20Canvas.clientHeight;
            if (renderer && camera) {
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }

            d20ResultOverlay.textContent = '';
            d20ResultOverlay.classList.remove('result-reveal-animation');

            // --- Set up the animation ---
            
            // 1. Pick a result, store it globally, and get the target rotation
            currentRollResult = Math.floor(Math.random() * 20) + 1;
            targetQuaternion = d20FaceQuaternions[currentRollResult - 1];

            // 2. Create a random starting rotation
            sourceQuaternion = new THREE.Quaternion();
            const randomAxis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
            // Use the improved angle for 4-7 rotations
            const randomAngle = (Math.random() * 3 * 2 * Math.PI) + (4 * 2 * Math.PI);
            sourceQuaternion.setFromAxisAngle(randomAxis, randomAngle);

            // 3. Kick off the animation loop. It will handle the rest.
            die.quaternion.copy(sourceQuaternion);
            isRolling = true;
            rollStartTime = Date.now();
            animate3DDice();
        }

        function onRollComplete() {
            // This function is called by the animation loop when the die stops.
            d20ResultOverlay.textContent = currentRollResult;
            d20ResultOverlay.classList.add('result-reveal-animation');
            addLogEntry(`You rolled a ${currentRollResult} on a d20`);

            // After a delay to show the result, hide the modal.
            setTimeout(() => {
                diceModal.classList.add('invisible');
            }, 600);
        }

        function startLoadingAnimation() {
            // Set the state immediately.
            isRolling = false;
            isLoading = true;

            // Make the modal visible.
            diceModal.classList.remove('invisible');
            d20ResultOverlay.textContent = '';
            
            // Schedule the resizing and animation to run just before the next browser paint.
            // This is the most reliable way to ensure the canvas has correct dimensions.
            requestAnimationFrame(() => {
                // If loading was stopped while this frame was pending, do nothing.
                if (!isLoading) return;

                if (!scene) init3DDice();

                const width = d20Canvas.clientWidth;
                const height = d20Canvas.clientHeight;
                if (renderer && camera) {
                    renderer.setSize(width, height);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                }
                
                // Kick off the animation loop.
                animate3DDice();
            });
        }

        function stopLoadingAnimation() {
            // This acts as a "cancellation" flag for any pending animation frame.
            isLoading = false;
            diceModal.classList.add('invisible');
        }

        function parseAndRoll(diceString) {
            const originalExpression = diceString.trim();
            // This regex captures the number of dice, sides, and the keep modifier (e.g., kh1)
            const diceRollRegex = /(\d+)d(\d+)((?:kh|kl)\d+)?/gi;
            let errorFromReplace = null; // Used to catch errors from inside the .replace() callback

            try {
                let rollDetails = []; // To store breakdown text like "Rolls: [18, 5], Kept: [18]"

                const processedString = originalExpression.replace(diceRollRegex, (match, numDiceStr, numSidesStr, keepModifier) => {
                    if (errorFromReplace) return ''; // Stop if an error was already found

                    const numDice = parseInt(numDiceStr, 10);
                    const numSides = parseInt(numSidesStr, 10);
                    let rolls = [];

                    for (let i = 0; i < numDice; i++) {
                        rolls.push(Math.floor(Math.random() * numSides) + 1);
                    }

                    let keptRolls = [...rolls];
                    let wasModified = false;

                    if (keepModifier) {
                        const keepType = keepModifier.slice(0, 2).toLowerCase();
                        const numToKeep = parseInt(keepModifier.slice(2), 10);

                        if (isNaN(numToKeep) || numToKeep <= 0) {
                            errorFromReplace = new Error(`Invalid number to keep in "${match}".`);
                            return '';
                        }
                        if (numToKeep > numDice) {
                            errorFromReplace = new Error(`Cannot keep ${numToKeep} dice; only ${numDice} were rolled in "${match}".`);
                            return '';
                        }

                        wasModified = true;
                        rolls.sort((a, b) => a - b); // Sort numerically
                        if (keepType === 'kh') {
                            keptRolls = rolls.slice(-numToKeep); // Get the highest rolls from the end
                        } else { // 'kl'
                            keptRolls = rolls.slice(0, numToKeep); // Get the lowest rolls from the start
                        }
                    }

                    const sum = keptRolls.reduce((a, b) => a + b, 0);

                    let detail = `Rolls: [${rolls.join(', ')}]`;
                    if (wasModified) {
                        detail += `, Kept: [${keptRolls.join(', ')}]`;
                    }
                    rollDetails.push(`${match}: ${detail}`);

                    return sum;
                });

                if (errorFromReplace) {
                    throw errorFromReplace; // Throw the captured error to be caught by the outer catch block
                }

                // Safely evaluate the final mathematical expression (e.g., "18 + 5")
                const sanitizedString = processedString.replace(/[^-()\d/*+.]/g, '');
                const total = new Function('return ' + sanitizedString)();

                return { 
                    total: Math.round(total), 
                    expression: originalExpression,
                    breakdown: rollDetails.join('; ')
                };

            } catch (e) {
                // This now correctly catches errors and logs them to the UI
                addLogEntry(`Error in "${originalExpression}": ${e.message || 'Invalid format.'}`);
                return null;
            }
        }

        // NEW: Helper function to programmatically add entries to the log
        function addLogEntry(text, isHtml = false) {
            const logEntry = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            // If the text is pre-formatted HTML, use it directly. Otherwise, sanitize it.
            const content = isHtml ? text : text.replace(/</g, "&lt;").replace(/>/g, "&gt;");

            // This uses a flex container with "items-start" to align the timestamp and the 
            // content to the top, which fixes the alignment for multi-line messages.
            logEntry.innerHTML = `
                <div class="flex items-start">
                    <span class="text-gray-500 mr-2 flex-shrink-0">[${timestamp}]</span>
                    <div class="flex-grow">${content}</div>
                </div>`;
            
            logDisplay.appendChild(logEntry);

            // Trim the log to the latest 100 entries
            while (logDisplay.children.length > 100) {
                logDisplay.removeChild(logDisplay.firstChild);
            }

            logDisplay.scrollTop = logDisplay.scrollHeight;
            saveState(); // Save state every time an entry is added
        }


        // --- Data ---
        const colorPalette = [
            'bg-red-500', 'bg-orange-500', 'bg-amber-500', 'bg-yellow-500', 'bg-lime-500', 'bg-green-500',
            'bg-emerald-500', 'bg-teal-500', 'bg-cyan-500', 'bg-sky-500', 'bg-blue-500', 'bg-indigo-500',
            'bg-violet-500', 'bg-purple-500', 'bg-fuchsia-500', 'bg-pink-500', 'bg-rose-500', 'bg-slate-500'
        ];
        let colorIndex = 0; // To cycle through colors for new characters
        let isHpHidden = false; // To track HP visibility state

        const statusSymbols = ['â˜ ï¸', 'ðŸ”¥', 'â„ï¸', 'âš¡ï¸', 'ðŸ›¡ï¸', 'âš”ï¸', 'â¤ï¸â€ðŸ©¹', 'ðŸ˜µ', 'ðŸ¤¢', 'â“', 'ðŸ’ª', 'ðŸŽ¯'];

        // --- IndexedDB Setup ---
        let db;
        const DB_NAME = 'initiativeTrackerDB';
        // Increased DB_VERSION to trigger onupgradeneeded for robust migration
        const DB_VERSION = 4;
        const IMAGE_STORE_NAME = 'images';
        const CHARACTER_STORE_NAME = 'characters'; // New store name

        function openIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    console.log(`IndexedDB upgrade needed from version ${event.oldVersion} to ${event.newVersion}`);

                    // Create or get 'images' store
                    let imageStore;
                    if (!db.objectStoreNames.contains(IMAGE_STORE_NAME)) {
                        imageStore = db.createObjectStore(IMAGE_STORE_NAME, { keyPath: 'id' });
                        console.log(`Created new '${IMAGE_STORE_NAME}' object store.`);
                    } else {
                        imageStore = request.transaction.objectStore(IMAGE_STORE_NAME);
                        console.log(`'${IMAGE_STORE_NAME}' object store already exists.`);
                    }

                    // Create or get 'characters' store
                    let characterStore;
                    if (!db.objectStoreNames.contains(CHARACTER_STORE_NAME)) {
                        characterStore = db.createObjectStore(CHARACTER_STORE_NAME, { keyPath: 'id' });
                        console.log(`Created new '${CHARACTER_STORE_NAME}' object store.`);
                    } else {
                        characterStore = request.transaction.objectStore(CHARACTER_STORE_NAME);
                        console.log(`'${CHARACTER_STORE_NAME}' object store already exists.`);
                    }

                    // Migration logic for old character data from localStorage to IndexedDB
                    // This will run if upgrading from a version where characters were exclusively in localStorage.
                    // Version 3 already moved characters to IndexedDB, but deleting existing stores on upgrade was a risk.
                    // This ensures data from pre-v3 states or fragmented v3 states is migrated.
                    if (event.oldVersion < 3) {
                        console.log("Attempting to migrate character data from localStorage to IndexedDB...");
                        // Access the transaction associated with the upgradeneeded event
                        const transaction = event.target.transaction;
                        const charStore = transaction.objectStore(CHARACTER_STORE_NAME);

                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            // Only process items that look like old character data saved individually
                            if (key && key.startsWith('char-')) {
                                try {
                                    const itemData = JSON.parse(localStorage.getItem(key));
                                    // Ensure it's character data and not just an order array
                                    if (itemData && typeof itemData === 'object' && itemData.type === 'character') {
                                        // Attempt to add, if ID already exists (e.g., from a partial v3 load), it will error, but not halt transaction
                                        charStore.put({ id: key, ...itemData }); // Use put to handle potential existing entries
                                        console.log(`Migrated character ${key} from localStorage to IndexedDB.`);
                                    }
                                } catch (e) {
                                    console.warn(`Could not parse or migrate localStorage item ${key}:`, e);
                                }
                            }
                        }
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('IndexedDB opened successfully');
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        async function saveImageToIndexedDB(id, blob) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.put({ id: id, blob: blob });

                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error("Failed to put image in IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function loadImageFromIndexedDB(id) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.get(id);

                request.onsuccess = (event) => resolve(event.target.result ? event.target.result.blob : null);
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        async function deleteImageFromIndexedDB(id) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.delete(id);

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        // NEW: Functions for character data in IndexedDB
        async function saveCharacterToIndexedDB(id, characterData) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CHARACTER_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CHARACTER_STORE_NAME);
                const request = store.put({ id: id, ...characterData });

                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error("Failed to put character in IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function loadCharacterFromIndexedDB(id) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CHARACTER_STORE_NAME], 'readonly');
                const store = transaction.objectStore(CHARACTER_STORE_NAME);
                const request = store.get(id);

                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => {
                    console.error("Failed to get character from IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function deleteCharacterFromIndexedDB(id) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CHARACTER_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CHARACTER_STORE_NAME);
                const request = store.delete(id);

                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error("Failed to delete character from IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // --- LocalStorage Persistence (now only for order) ---
        async function saveState() {
            try {
                // Save order and other UI states from localStorage
                const initiativeOrder = Array.from(shelf.children).map(item => item.id);
                localStorage.setItem('initiativeOrder', JSON.stringify(initiativeOrder));
                const compendiumOrder = Array.from(compendiumShelfInner.children).map(item => item.id);
                localStorage.setItem('compendiumOrder', JSON.stringify(compendiumOrder));
                localStorage.setItem('isLogOpen', document.body.classList.contains('log-open'));
                localStorage.setItem('logContent', logDisplay.innerHTML);
                localStorage.setItem('isHpHidden', JSON.stringify(isHpHidden));

                // Save Turn Marker data
                const turnMarker = document.querySelector('[id^="turn-marker-"]');
                if (turnMarker) {
                    const turnMarkerData = {
                        type: 'turnMarker',
                        turn: turnMarker.querySelector('.turn-counter')?.textContent.trim() || '1'
                    };
                    localStorage.setItem(turnMarker.id, JSON.stringify(turnMarkerData));
                }

                const characterPromises = [];
                for (const [id, character] of characterRegistry.entries()) {
                    characterPromises.push(saveCharacterToIndexedDB(id, character.toJSON()));
                }
                await Promise.all(characterPromises);

            } catch (e) {
                console.error("Failed to save state:", e);
            }
        }

        async function loadItemsToShelf(orderKey, targetParent) {
            const orderJSON = localStorage.getItem(orderKey);
            if (!orderJSON) return;

            const order = JSON.parse(orderJSON);
            const itemPromises = order.map(async (id) => {
                if (id.startsWith('turn-marker')) {
                    const turnMarkerJSON = localStorage.getItem(id);
                    return turnMarkerJSON ? { id, data: JSON.parse(turnMarkerJSON) } : null;
                } else {
                    const characterData = await loadCharacterFromIndexedDB(id);
                    if (!characterData) return null;
                    return { id, data: characterData };
                }
            });

            const loadedItems = await Promise.all(itemPromises);

            for (const item of loadedItems) {
                if (!item) continue;
                const { id, data } = item;
                if (data.type === 'turnMarker') {
                    createTurnMarker(id, data.turn, true);
                } else {
                    let bgImageUrl = '';
                    if (data.bgImageKey && data.bgImageKey.startsWith('indexeddb://')) {
                        const blob = await loadImageFromIndexedDB(data.bgImageKey).catch(e => console.error(e));
                        if(blob) bgImageUrl = URL.createObjectURL(blob);
                    } else if (data.bgImageKey) {
                        bgImageUrl = data.bgImageKey;
                    }

                    createCharacter({
                        ...data,
                        id: id,
                        parent: targetParent,
                        // This property isn't stored, but needed for rendering
                        bgImageUrl: bgImageUrl 
                    }, true);
                }
            }
        }

        async function loadState() {
            try {
                shelf.innerHTML = '';
                compendiumShelfInner.innerHTML = '';
                characterRegistry.clear();
                colorIndex = 0;

                await loadItemsToShelf('initiativeOrder', shelf);
                await loadItemsToShelf('compendiumOrder', compendiumShelfInner);

                isHpHidden = JSON.parse(localStorage.getItem('isHpHidden')) || false;
                if (isHpHidden) {
                    hideHpButton.textContent = 'Show HP';
                    hideHpButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                    hideHpButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
                }

                const savedLogContent = localStorage.getItem('logContent');
                if (savedLogContent) {
                    logDisplay.innerHTML = savedLogContent;
                    logDisplay.scrollTop = logDisplay.scrollHeight;
                }
                const isLogOpen = JSON.parse(localStorage.getItem('isLogOpen')) || false;
                if (isLogOpen) {
                    document.body.classList.add('log-open');
                }

                console.log('State loaded from IndexedDB and localStorage.');
                updateActionButtonsState();
                
                return {
                    initiativeCount: shelf.children.length,
                    compendiumCount: compendiumShelfInner.children.length
                };

            } catch (e) {
                console.error("Failed to load or parse state:", e);
                return { initiativeCount: 0, compendiumCount: 0 };
            }
        }


        // --- Core Functions for Item States ---

        function updateActionButtonsState() {
            const selectedItems = document.querySelectorAll('.highlighted');
            const buttonsToUpdate = [removeButton, copyButton, addStatusButton, clearStatusesButton, notesButton];

            if (selectedItems.length > 0) {
                buttonsToUpdate.forEach(button => {
                    button.disabled = false;
                    button.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                });
                removeButton.classList.add('bg-red-600', 'hover:bg-red-700', 'focus:ring-4', 'focus:ring-red-300');
                copyButton.classList.add('bg-teal-600', 'hover:bg-teal-700', 'focus:ring-4', 'focus:ring-teal-300');
                addStatusButton.classList.add('bg-purple-600', 'hover:bg-purple-700', 'focus:ring-4', 'focus:ring-purple-300');
                clearStatusesButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-4', 'focus:ring-yellow-300');
                notesButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700', 'focus:ring-4', 'focus:ring-indigo-300');
            } else {
                buttonsToUpdate.forEach(button => {
                    button.disabled = true;
                    button.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                    button.classList.remove(
                        'bg-red-600', 'hover:bg-red-700', 'focus:ring-red-300',
                        'bg-teal-600', 'hover:bg-teal-700', 'focus:ring-teal-300',
                        'bg-purple-600', 'hover:bg-purple-700', 'focus:ring-purple-300',
                        'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-300',
                        'bg-indigo-600', 'hover:bg-indigo-700', 'focus:ring-indigo-300',
                        'focus:ring-4'
                    );
                });
            }
        }

        function initializeDraggable(item) {
            item.setAttribute('draggable', true);
            
            item.addEventListener('dragstart', (e) => {
                if (!item.classList.contains('highlighted')) {
                    document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                    item.classList.add('highlighted');
                    if (item.parentElement.id === 'compendium-shelf-inner') {
                        refreshCompendiumLayout();
                    }
                }
                item.dataset.originalParentId = item.parentElement.id;
                // Store the next sibling ID for re-insertion, if necessary
                item.dataset.originalNextSiblingId = item.nextSibling ? item.nextSibling.id : 'null';
                setTimeout(() => item.classList.add('dragging'), 0);
            });

            item.addEventListener('dragend', async (e) => { // Marked as async for await calls
                item.classList.remove('dragging');
                const originalParentId = item.dataset.originalParentId;
                if (!originalParentId) return;

                const newParent = item.parentElement; // This is the DOM element where the drag ended

                const isCrossContainerDrag = (newParent && originalParentId !== newParent.id);
                const isCharacterCard = item.id.startsWith('char-');

                if (isCrossContainerDrag && isCharacterCard) {
                    const characterToCopy = Character.fromElement(item); // Get original character data
                    if (characterToCopy) {
                        const exactCopyData = characterToCopy.toJSON();
                        
                        // Create a NEW character element and object in the target parent.
                        // We explicitly pass true for skip_save, because the overall saveState()
                        // at the end of dragend will handle saving the order.
                        createCharacter({
                            ...exactCopyData,
                            parent: newParent,
                            insertBeforeSibling: item.nextElementSibling // Use item's current position for insertion hint
                        }, true); // Pass true to skip_save: important to prevent premature saves and re-renders

                        // Now, determine if the original item should be removed or restored
                        if (originalParentId === 'shelf-items') {
                            // Scenario: Dragging from Initiative (shelf) to Compendium (MOVE)
                            // The original item should be removed from the initiative shelf and its data deleted.
                            await deleteCharacterFromIndexedDB(item.id); // Delete character data from DB
                            characterRegistry.delete(item.id); // Remove from in-memory registry
                            item.remove(); // Remove the original DOM element from its previous parent
                        } else if (originalParentId === 'compendium-shelf-inner') {
                            // Scenario: Dragging from Compendium to Initiative (COPY)
                            // The original item should remain in the compendium.
                            // The browser's native drag-and-drop might visually move the element,
                            // so we explicitly ensure it's returned to its original place in the DOM.
                            const originalParentEl = document.getElementById(originalParentId);
                            const originalNextSiblingId = item.dataset.originalNextSiblingId;
                            const originalNextSiblingEl = (originalNextSiblingId && originalNextSiblingId !== 'null') ? document.getElementById(originalNextSiblingId) : null;
                            if (originalParentEl) {
                                // Clear any inline styles set by the drag operation
                                item.style.position = '';
                                item.style.top = '';
                                item.style.left = '';
                                item.style.transform = '';
                                item.style.zIndex = '';
                                // Re-insert the original item back into its source container
                                if (originalNextSiblingEl) {
                                    originalParentEl.insertBefore(item, originalNextSiblingEl);
                                } else {
                                    originalParentEl.appendChild(item);
                                }
                            }
                        }
                    }
                } else if (!isCrossContainerDrag && isCharacterCard) {
                    // This is an intra-container re-order. The DOM is already updated by dragover.
                    // No need to create new characters or remove old ones.
                    // The final saveState() will capture the new order.
                }

                // Clean up temporary dataset attributes regardless of drag type.
                delete item.dataset.originalParentId;
                delete item.dataset.originalNextSiblingId;

                // Refresh compendium layout if any compendium operation occurred, to re-stack cards.
                if (newParent?.id.includes('compendium') || originalParentId.includes('compendium')) {
                    refreshCompendiumLayout();
                }
                
                // A single, final save of the entire state after all DOM manipulations are complete.
                await saveState();
            });
        }


        function initializeSelectable(item) {
            if (!item.classList.contains('character-card')) return;

            item.addEventListener('click', (event) => {
                // Ignore clicks on editable fields or the notes indicator.
                if (event.target.getAttribute('contenteditable') === 'true' || event.target.closest('.notes-indicator')) return;

                const inCompendium = item.parentElement.id === 'compendium-shelf-inner';

                if (event.shiftKey) {
                    // --- Multi-selection logic (Shift+Click) ---
                    if (inCompendium) {
                        // If shift-clicking in compendium, clear all initiative highlights first.
                        document.querySelectorAll('#shelf-items .highlighted').forEach(el => el.classList.remove('highlighted'));
                    } else {
                        // If shift-clicking in initiative, clear all compendium highlights first.
                        document.querySelectorAll('#compendium-shelf-inner .highlighted').forEach(el => el.classList.remove('highlighted'));
                    }
                    // Then, toggle the highlight on the clicked item.
                    item.classList.toggle('highlighted');

                } else {
                    // --- Single selection logic (regular Click) ---
                    const isAlreadySelected = item.classList.contains('highlighted');
                    const totalSelected = document.querySelectorAll('.highlighted').length;

                    // First, clear all highlights from both containers.
                    document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));

                    // If the clicked item wasn't the only one selected, re-highlight it.
                    // This allows a click on a single selected item to deselect it.
                    if (!isAlreadySelected || totalSelected > 1) {
                        item.classList.add('highlighted');
                    }
                }

                // Always refresh compendium layout if it was involved.
                if (inCompendium) {
                    refreshCompendiumLayout();
                }
                
                // Update the state of the main action buttons.
                updateActionButtonsState();
            });
        }

        function initializeEditableFields(cardElement) {
            const fields = [
                { selector: '.font-bold.text-lg', property: 'name' },
                { selector: '.current-hp', property: 'hp' },
                { selector: '.total-hp', property: 'totalHp' },
                { selector: '.initiative-value', property: 'initiative' },
                { selector: '.initiative-bonus', property: 'initiativeBonus' },
            ];

            fields.forEach(({ selector, property }) => {
                const span = cardElement.querySelector(selector);
                if (!span) return;

                // This function must be async to await the render.
                const resolveChange = async () => { 
                    const character = Character.fromElement(cardElement);
                    if (character) {
                        let value = span.textContent.trim();
                        if (property === 'name') {
                            character.name = value;
                        } else {
                            try {
                                const calculatedValue = new Function('return ' + value.replace(/[^-()\d/*+.]/g, ''))();
                                character[property] = isNaN(calculatedValue) ? 0 : Math.round(calculatedValue);
                            } catch (e) {
                                character[property] = parseInt(value, 10) || 0;
                            }
                        }
                        await character.render(); 
                        saveState();
                    }
                };

                span.addEventListener('blur', resolveChange);
                span.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        span.blur();
                    }
                });
            });
        }

        function initializeContextMenu(item) {
            item.addEventListener('contextmenu', e => {
                e.preventDefault();
                if (!item.classList.contains('character-card')) return;

                if (!item.classList.contains('highlighted')) {
                    document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
                    item.classList.add('highlighted');
                    updateActionButtonsState();
                }

                if (item.parentElement.id === 'compendium-shelf-inner') {
                    refreshCompendiumLayout();
                }

                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.classList.remove('invisible');
            });
        }

        shelf.addEventListener('dragover', e => {
            e.preventDefault();
            const draggingItem = document.querySelector('.dragging');
            if (!draggingItem) return;
            draggingItem.style.position = '';
            const afterElement = getDragAfterElement(shelf, e.clientX, e.clientY);
            if (afterElement == null) {
                shelf.appendChild(draggingItem);
            } else {
                shelf.insertBefore(draggingItem, afterElement);
            }
        });

        compendiumShelf.addEventListener('dragover', e => {
            const draggingItem = document.querySelector('.dragging');

            // If the dragging item is the turn marker, prevent any drop action here.
            if (draggingItem && draggingItem.id.startsWith('turn-marker')) {
                return;
            }
            e.preventDefault(); // This is necessary to allow a drop.
            if (draggingItem) {
                // This is the logic that determines where the dragged item should be placed.
                const afterElement = getDragAfterElement(compendiumShelfInner, e.clientX, e.clientY);
                
                // This re-orders the element in the DOM in real-time.
                if (afterElement) {
                    compendiumShelfInner.insertBefore(draggingItem, afterElement);
                } else {
                    compendiumShelfInner.appendChild(draggingItem);
                }
            }
        });

        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];

            // Find the element visually closest to the cursor using 2D distance
            const closest = draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            // Pythagorean theorem to find the true distance to the center of the child
            const distance = Math.sqrt(Math.pow(x - (box.left + box.width / 2), 2) + Math.pow(y - (box.top + box.height / 2), 2));

            if (distance < closest.distance) {
                return { distance, element: child };
            } else {
                return closest;
            }
            }, { distance: Number.POSITIVE_INFINITY });

            const closestElement = closest.element;

            if (closestElement) {
                const box = closestElement.getBoundingClientRect();
                // If the cursor is in the right half of the closest element, we want to insert AFTER it.
                // So, we return its next sibling as the insertion point.
                if (x > box.left + box.width / 2) {
                    return closestElement.nextElementSibling;
                } else {
                    // Otherwise, we insert BEFORE it by returning the element itself.
                    return closestElement;
                }
            } else {
                // If there are no other elements, return null to append at the end.
                return null;
            }
        }

        // --- HP Display Logic ---
        function updateCharacterHpDisplay(characterElement) {
            const standardView = characterElement.querySelector('.hp-standard-view');
            const damageView = characterElement.querySelector('.hp-damage-view');
            const damageText = characterElement.querySelector('.damage-text');
            const hpHeader = characterElement.querySelector('.hp-header');

            if (!standardView || !damageView || !damageText || !hpHeader) return;

            if (isHpHidden) {
                // Hide the standard HP view (e.g., "10 / 18")
                standardView.classList.add('invisible');
                hpHeader.classList.add('invisible');

                const character = Character.fromElement(characterElement);
                if (!character) return; // Safety check

                const currentHp = parseInt(character.hp, 10) || 0;
                const totalHp = parseInt(character.totalHp, 10) || 0;
                const damage = totalHp - currentHp;

                // If character is damaged, show the damage text.
                if (damage > 0) {
                    damageText.textContent = `${damage} damage`;
                    // To ensure the view is visible, remove both Tailwind's 'hidden' class (display: none)
                    // and our custom 'invisible' class (opacity: 0).
                    damageView.classList.remove('hidden');
                    damageView.classList.remove('invisible');
                } else {
                    // If character is at full health, hide the damage view.
                    damageText.textContent = '';
                    damageView.classList.add('invisible');
                }
            } else {
                // If not in "Hide HP" mode, revert to the standard view.
                standardView.classList.remove('invisible');
                hpHeader.classList.remove('invisible');
                damageView.classList.add('invisible');
            }
        }

        function updateAllCharacterHpDisplay() {
            document.querySelectorAll('.character-card').forEach(updateCharacterHpDisplay);
        }

        // --- Compendium Layout Logic ---
        function refreshCompendiumLayout(applyFilters=false) {
            const allItems = Array.from(compendiumShelfInner.children);
            let visibleItems = [];

            if(applyFilters) {
                console.log("Applying filters to compendium items...");
                const searchTerm = compendiumSearch.value.toLowerCase();
                let minCr = NaN;
                let maxCr = NaN;
                try {
                    minCr = eval(minCrInput.value);
                } catch (e) {
                    // No need to log a failed eval
                }
                try {
                    maxCr = eval(maxCrInput.value);
                } catch (e) {
                    // No need to log a failed eval
                }
                allItems.forEach(item => {
                    const name = item.querySelector('.font-bold.text-lg').textContent.toLowerCase();
                    let cr = NaN;
                    try {
                        cr = eval(item.dataset.challenge);
                    }  catch (e) {
                        // No need to log a failed eval
                    }
                    
                    // Filtering logic:
                    const shouldFilterOut = !name.includes(searchTerm) ||
                                          (!isNaN(minCr) && (isNaN(cr) || cr < minCr)) || // Ensure minCr is a number before comparing
                                          (!isNaN(maxCr) && (isNaN(cr) || cr > maxCr));    // Ensure maxCr is a number before comparing

                    if (shouldFilterOut) {
                        item.setAttribute('shouldFilterOut', true);
                    } else {
                        item.removeAttribute('shouldFilterOut');
                    }
                });
            }

            allItems.forEach(item => {
                if (item.getAttribute('shouldFilterOut')) {
                    item.style.display = 'none';
                } else {
                    item.style.display = 'block';
                    visibleItems.push(item);
                }
            });

            const highlightedItem = compendiumShelfInner.querySelector('.highlighted');
            if (highlightedItem && highlightedItem.style.display === 'none') {
                highlightedItem.classList.remove('highlighted');
            }
            updateCompendiumStack(visibleItems);
        }

        function updateCompendiumStack(visibleItems) {
            if (visibleItems.length === 0) {
                compendiumShelfInner.style.height = '0px';
                return;
            };

            let highlightedItem = compendiumShelfInner.querySelector('.highlighted');
            if (!highlightedItem) {
                highlightedItem = visibleItems[0];
                highlightedItem.classList.add('highlighted');
            }

            const cardHeight = 224;
            const overlap = cardHeight * 0.85;
            const step = cardHeight - overlap;

            const totalHeight = (visibleItems.length - 1) * step + cardHeight + 40;
            compendiumShelfInner.style.height = `${totalHeight}px`;

            const highlightedIndex = visibleItems.indexOf(highlightedItem);
            const topAnchor = 16 + (highlightedIndex * step);

            highlightedItem.style.top = `${topAnchor}px`;
            highlightedItem.style.zIndex = visibleItems.length;
            highlightedItem.style.transform = 'translateX(-50%) scale(1.05)';

            for (let i = 0; i < visibleItems.length; i++) {
                const item = visibleItems[i];
                if (item === highlightedItem) continue;
                const distance = i - highlightedIndex;
                item.style.top = `${topAnchor + (distance * step)}px`;
                item.style.zIndex = visibleItems.length - 1 - Math.abs(distance);
                item.style.transform = 'translateX(-50%) scale(1)';
            }
        }


        function cycleCompendiumHighlight(direction) {
            const items = Array.from(compendiumShelfInner.children).filter(item => item.style.display !== 'none');
            if (items.length < 2) return;

            let currentHighlighted = compendiumShelfInner.querySelector('.highlighted');
            if (!currentHighlighted) {
                items[0].classList.add('highlighted');
                refreshCompendiumLayout();
                items[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                return;
            }

            const currentIndex = items.indexOf(currentHighlighted);
            currentHighlighted.classList.remove('highlighted');

            let nextIndex;
            if (direction === 'down') {
                nextIndex = (currentIndex + 1) % items.length;
            } else { // 'up'
                nextIndex = (currentIndex - 1 + items.length) % items.length;
            }

            const newItem = items[nextIndex];
            newItem.classList.add('highlighted');
            updateActionButtonsState();
            refreshCompendiumLayout();
            newItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function createCharacter(options, skip_save = false) {
            const character = new Character(options);
            characterRegistry.set(character.id, character);

            const newItem = document.createElement('div');
            newItem.id = character.id;
            newItem.classList.add('character-card', 'draggable', 'rounded-md', 'w-40', 'min-h-64', 'shadow-lg', 'flex', 'flex-col', 'justify-between', 'p-2', 'text-white');
            
            const namePlaceholder = character.name ? '' : 'data-placeholder="Name"';

            newItem.innerHTML = `
                <div class="flex flex-col items-center flex-shrink-0">
                    <span contenteditable="true" class="font-bold text-lg p-1 text-center text-readable break-words" ${namePlaceholder}>${character.name}</span>
                    <div class="flex flex-col items-center mt-2">
                        <span class="hp-header text-xs font-semibold text-white/80 select-none text-readable">HP</span>
                        <div class="hp-display-container">
                            <div class="hp-standard-view flex items-baseline justify-center">
                                <span contenteditable="true" class="current-hp text-2xl font-mono p-1 text-readable">${character.hp}</span>
                                <span class="mx-1 text-white/80">/</span>
                                <span contenteditable="true" class="total-hp text-2xl font-mono p-1 text-readable">${character.totalHp}</span>
                            </div>
                            <div class="hp-damage-view hidden text-center h-9 flex items-center justify-center">
                                <span class="damage-text text-lg font-semibold p-1 text-readable text-red-300"></span>
                            </div>
                        </div>
                    </div>
                    <div class="flex flex-col items-center mt-1">
                        <span class="text-xs font-semibold text-white/80 select-none text-readable">Initiative</span>
                        <div class="flex items-baseline justify-center">
                            <span contenteditable="true" class="initiative-value text-xl font-mono p-1 text-readable">${character.initiative}</span>
                            <div class="flex items-baseline">
                                <span class="mx-1 text-white/80">(</span>
                                <span contenteditable="true" class="initiative-bonus text-base font-mono p-1 text-readable">${character.initiativeBonus}</span>
                                <span class="text-white/80">)</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="status-container w-full flex-grow mt-2 p-1 flex flex-wrap items-center justify-center content-start gap-2 overflow-y-auto"></div>
                <div class="absolute bottom-1 right-1 notes-indicator text-lg" style="display: none;">ðŸ“</div>
            `;

            // Add the new element to the DOM *before* rendering it.
            const parent = options.parent || shelf;
            if (options.insertBeforeSibling) {
                parent.insertBefore(newItem, options.insertBeforeSibling);
            } else if (options.insertionElement) {
                options.insertionElement.after(newItem);
            } else {
                parent.appendChild(newItem);
            }

            // Now that the element is in the DOM, call render to apply data.
            character.render(); 

            // Initialize event listeners
            initializeDraggable(newItem);
            initializeSelectable(newItem);
            initializeContextMenu(newItem);
            initializeEditableFields(newItem); 
            
            if (parent.id === 'compendium-shelf-inner') {
                newItem.style.position = 'absolute';
                refreshCompendiumLayout();
            }

            if (!options.id) { 
                newItem.classList.add('pop-in-animation');
                newItem.addEventListener('animationend', () => newItem.classList.remove('pop-in-animation'), { once: true });
            }
            
            if (!skip_save) {
                saveState();
            }
            return newItem;
        }

        function createTurnMarker(id = null, turn = '1', skip_save = false) {
            const turnMarker = document.createElement('div');
            turnMarker.id = id || `turn-marker-${crypto.randomUUID()}`;
            turnMarker.className = 'draggable flex items-end h-64';

            turnMarker.innerHTML = `
                <div class="w-4 h-full bg-black rounded-l-lg"></div>
                <div class="bg-black text-white p-2 rounded-r-lg shadow-lg">
                    <div class="text-xs font-semibold uppercase text-white/80 select-none">Turn</div>
                    <span class="turn-counter text-2xl font-mono" contenteditable="true">${turn}</span>
                </div>
            `;

            initializeDraggable(turnMarker);

            const turnCounterSpan = turnMarker.querySelector('.turn-counter');
            turnCounterSpan.addEventListener('blur', saveState);
            turnCounterSpan.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter') { e.preventDefault(); turnCounterSpan.blur(); }
            });

            shelf.appendChild(turnMarker);
            if (!skip_save) {
                saveState();
            }            
            return turnMarker; // Return the created turn marker
        }

        /**
         * Rolls initiative for all characters on the main shelf, sorts them,
         * and logs the results.
         */
        async function rollInitiatives() {
            const charactersOnShelf = Array.from(shelf.querySelectorAll('.character-card'));
            if (charactersOnShelf.length === 0) {
                addLogEntry("No characters in initiative to roll for.");
                return;
            }

            let initiativeRolls = [];
            let tieOccurred = false;

            // 1. Roll initiative for each character
            for (const charElement of charactersOnShelf) {
                const character = Character.fromElement(charElement);
                if (character) {
                    const bonus = parseInt(character.initiativeBonus, 10) || 0;
                    const roll = Math.floor(Math.random() * 20) + 1;
                    character.initiative = roll + bonus;
                    
                    // Store details for logging and sorting
                    initiativeRolls.push({ 
                        element: charElement, 
                        character: character,
                        finalInitiative: character.initiative,
                        log: `<strong>${character.name}</strong> rolled ${character.initiative} (d20: ${roll} + bonus: ${bonus})`
                    });
                    
                    await character.render(); // Update the card display
                }
            }

            // 2. Sort characters by initiative, with random tie-breaking
            initiativeRolls.sort((a, b) => {
                if (b.finalInitiative === a.finalInitiative) {
                    tieOccurred = true;
                    return Math.random() - 0.5; // Randomly sort ties
                }
                return b.finalInitiative - a.finalInitiative;
            });

            // 3. Re-order the elements in the DOM
            initiativeRolls.forEach(item => {
                shelf.appendChild(item.element);
            });

            // 4. Reset the turn marker and move it to the top
            const turnMarker = shelf.querySelector('[id^="turn-marker-"]');
            if (turnMarker) {
                const counter = turnMarker.querySelector('.turn-counter');
                if(counter) counter.textContent = '1';
                shelf.prepend(turnMarker);
            }

            // 5. Build and display the log message
            let logMessage = '<strong>--- Initiative Rolls ---</strong><ul>';
            initiativeRolls.forEach(item => {
                logMessage += `<li>${item.log}</li>`;
            });
            logMessage += '</ul>';
            if (tieOccurred) {
                logMessage += '<span class="text-gray-400">(Ties were resolved randomly.)</span>';
            }
            
            addLogEntry(logMessage, true);

            // 6. Ensure the log is visible
            if (!document.body.classList.contains('log-open')) {
                logHandle.click();
            }
            
            // 7. Save the new state
            await saveState();
        }

        // --- Modal & Menu Logic ---
        function populateSymbolModal(selectedItems) {
            symbolGrid.innerHTML = '';
            statusSymbols.forEach((symbol) => {
                const symbolButton = document.createElement('button');
                symbolButton.className = "relative text-3xl p-4 rounded-lg hover:bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500";

                const allHaveStatus = Array.from(selectedItems).every(item => {
                    const char = Character.fromElement(item);
                    return char && char.statuses.includes(symbol);
                });

                if (allHaveStatus) symbolButton.classList.add('symbol-selected');
                symbolButton.innerHTML = `<span class="pointer-events-none">${symbol}</span><span class="absolute bottom-1 right-1 text-xs font-mono bg-gray-600 text-white rounded-sm px-1.5 py-0.5 pointer-events-none">${(statusSymbols.indexOf(symbol) + 1) % 10}</span>`;

                // This event listener must be async.
                symbolButton.addEventListener('click', async () => { 
                    for (const item of selectedItems) {
                        const character = Character.fromElement(item);
                        if (!character) continue;

                        if (allHaveStatus) {
                            character.statuses = character.statuses.filter(s => s !== symbol);
                        } else {
                            if (!character.statuses.includes(symbol)) {
                                character.statuses.push(symbol);
                            }
                        }
                        await character.render(); 
                    }
                    populateSymbolModal(selectedItems);
                    saveState();
                });
                symbolGrid.appendChild(symbolButton);
            });
        }

        function populateColorMenu() {
            colorGrid.innerHTML = '';
            colorPalette.forEach(color => {
                const swatch = document.createElement('button');
                swatch.className = `w-8 h-8 rounded-full ${color} border-2 border-white/50 hover:scale-110 transition-transform`;
                // This event listener must be async.
                swatch.addEventListener('click', async () => { 
                    for (const item of document.querySelectorAll('.highlighted')) {
                        const character = Character.fromElement(item);
                        if (character) {
                            character.bgImageKey = '';
                            character.bgColor = color;
                            await character.render(); 
                        }
                    };
                    contextMenu.classList.add('invisible');
                    saveState();
                });
                colorGrid.appendChild(swatch);
            });
        }

        function handleStatusModalToggle() {
             if (!statusModal.classList.contains('invisible')) {
                statusModal.classList.add('invisible');
            } else if (!addStatusButton.disabled) {
                const selectedItems = document.querySelectorAll('.highlighted');
                if (selectedItems.length > 0) {
                    populateSymbolModal(selectedItems);
                    statusModal.classList.remove('invisible');
                }
            }
        }

        function updateNotesIndicator(item) {
            const indicator = item.querySelector('.notes-indicator');
            if (indicator) indicator.style.display = item.dataset.notes ? 'block' : 'none';
        }

        function makeDiceRollsClickable(htmlString) {
            // This regex identifies three patterns in order of priority:
            // 1. Full dice notation like "1d8+2".
            // 2. Parenthesized modifiers like "(-1)".
            // 3. Standalone modifiers like "+6", but only when they are preceded by a space or a '>' from an HTML tag.
            //    This is the key fix. It captures the preceding character so we can put it back.
            const rollRegex = /\b(\d+d\d+(?:\s*[+-]\s*\d+)?)\b|\((\s*[+-]\s*\d+)\)|(>|\s)([+-]\d+)\b/gi;

            return htmlString.replace(rollRegex, (match, standardRoll, parenModifier, prefixForStandalone, standaloneModifier) => {
                let rollExpression = '';
                let title = '';
                
                if (standardRoll) {
                    // Case 1: Matched a standard dice expression (e.g., "2d6", "1d20 + 5")
                    rollExpression = standardRoll.replace(/\s/g, '');
                    title = `Click to roll ${rollExpression}`;
                    // Just wrap the original match to preserve spacing
                    return `<span class="clickable-roll" data-roll="${rollExpression}" title="${title}">${match}</span>`;
                
                } else if (parenModifier) {
                    // Case 2: Matched a parenthesized modifier (e.g., "(-1)")
                    const modifier = parenModifier.replace(/\s/g, '');
                    rollExpression = `1d20${modifier}`;
                    title = `Click to roll ${rollExpression}`;
                    // Wrap the original match
                    return `<span class="clickable-roll" data-roll="${rollExpression}" title="${title}">${match}</span>`;
                
                } else if (standaloneModifier) {
                    // Case 3: Matched a standalone modifier (e.g., " +4" or ">+4")
                    const modifier = standaloneModifier.replace(/\s/g, '');
                    rollExpression = `1d20${modifier}`;
                    title = `Click to roll ${rollExpression}`;
                    // IMPORTANT: We must put the captured prefix (the space or '>') back before our span.
                    return `${prefixForStandalone}<span class="clickable-roll" data-roll="${rollExpression}" title="${title}">${standaloneModifier}</span>`;
                }

                // Fallback in case of an unexpected match
                return match;
            });
        }

        function openNotesModal() {
            const selectedItems = document.querySelectorAll('.highlighted');
            if (selectedItems.length === 0) return;

            const firstItem = selectedItems[0];
            const name = firstItem.querySelector('.font-bold.text-lg').textContent.trim() || 'Unnamed Character';
            notesTitle.textContent = `Notes for ${name}`;
            if (selectedItems.length > 1) notesTitle.textContent += ` (+${selectedItems.length - 1} others)`;

            // Get the raw, clean notes HTML from the character data
            const rawNotes = firstItem.dataset.notes || '';
            const character = Character.fromElement(firstItem);

            // Populate the challenge input field
            notesChallengeInput.value = character ? character.challenge : '';
            
            // 1. Put the clickable version in the view pane
            const processedNotes = makeDiceRollsClickable(rawNotes);
            document.getElementById('notes-view-content').innerHTML = processedNotes;

            // 2. Put the raw HTML in the edit pane (a contenteditable div now)
            document.getElementById('notes-edit-content').innerHTML = rawNotes;

            // 3. Set to view mode by default, challenge input remains enabled
            notesModal.classList.remove('edit-mode');
            notesToggleEditBtn.textContent = 'Edit';
            notesChallengeInput.disabled = true;

            notesModal.classList.remove('invisible');
        }

        function closeNotesModal() {
            // This function should NOT save. Saving is handled explicitly by the Edit/Save button.
            // It should just hide the modal, discarding any unsaved changes if in edit mode.
            notesModal.classList.add('invisible');
        }

        notesButton.addEventListener('click', openNotesModal);
        document.getElementById('notes-view-content').addEventListener('click', (e) => {
            if (e.target.classList.contains('clickable-roll')) {
                const diceExpression = e.target.dataset.roll;
                if (!diceExpression) return;

                const result = parseAndRoll(diceExpression);

                if (result !== null) {
                    const finalLogMessage = `Rolled <strong>${result.expression}</strong> &rarr; <strong class="text-xl text-yellow-300">${result.total}</strong>` + 
                                        (result.breakdown ? `<br><span class="text-gray-400 text-xs">${result.breakdown}</span>` : '');
                    addLogEntry(finalLogMessage, true);

                    if (!document.body.classList.contains('log-open')) {
                        logHandle.click();
                    }
                }
            }
        });
        closeNotesModalButton.addEventListener('click', closeNotesModal);
        notesToggleEditBtn.addEventListener('click', async () => { 
            const isInEditMode = notesModal.classList.contains('edit-mode');
            if (isInEditMode) {
                // Save logic
                const rawNotes = document.getElementById('notes-edit-content').innerHTML;
                const challengeValue = notesChallengeInput.value.trim(); // Get the challenge value

                for (const item of document.querySelectorAll('.highlighted')) {
                    const character = Character.fromElement(item);
                    if (character) {
                        character.notes = rawNotes;
                        character.challenge = challengeValue; // Save the challenge value
                        await character.render(); 
                    }
                }
                saveState();
                notesModal.classList.remove('edit-mode');
                notesToggleEditBtn.textContent = 'Edit';
                document.getElementById('notes-view-content').innerHTML = makeDiceRollsClickable(rawNotes);
                notesChallengeInput.disabled = true;
            } else {
                // Edit logic
                notesModal.classList.add('edit-mode');
                notesToggleEditBtn.textContent = 'Save';
                notesChallengeInput.disabled = false;
                setTimeout(() => document.getElementById('notes-edit-content').focus(), 0);
            }
        });
        addStatusButton.addEventListener('click', handleStatusModalToggle);
        closeModalButton.addEventListener('click', () => statusModal.classList.add('invisible')); // Existing close button for status modal.
        statusModal.addEventListener('click', (e) => { if (e.target === statusModal) statusModal.classList.add('invisible'); });

        // Fix for the Image URL button
        applyUrlButton.addEventListener('click', async () => { 
            const url = imageUrlInput.value.trim();
            if (url) {
                for (const item of document.querySelectorAll('.highlighted')) {
                    const character = Character.fromElement(item);
                    if (character) {
                        character.bgImageKey = url;
                        await character.render(); 
                    }
                };
                saveState();
            }
            contextMenu.classList.add('invisible');
            imageUrlInput.value = '';
        });

        imageFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const imageId = `indexeddb://${crypto.randomUUID()}`;
                await saveImageToIndexedDB(imageId, file);
                
                // Changed from forEach to a for...of loop, which is compatible with await.
                for (const item of document.querySelectorAll('.highlighted')) {
                    const character = Character.fromElement(item);
                    if (character) {
                        character.bgImageKey = imageId;
                        // This await is now valid because it's inside an async function's loop.
                        await character.render();
                    }
                }
                
                saveState(); // Save the state after all renders are complete.
            }
            contextMenu.classList.add('invisible');
            e.target.value = null; // Clear the input for the next upload.
        });

        manageCompendiumDataBtn.addEventListener('click', async () => {
            const compendiumItems = Array.from(compendiumShelfInner.children);
            const exportDataPromises = compendiumItems.map(async item => {
                const character = Character.fromElement(item);
                if (!character) return null;

                // Get the base data object from the instance
                const characterData = character.toJSON();

                // Handle image export separately by converting stored images to base64
                let exportedImage = characterData.bgImageKey || '';
                if (exportedImage.startsWith('indexeddb://')) {
                    const blob = await loadImageFromIndexedDB(exportedImage);
                    if (blob) {
                        exportedImage = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result); // Converts to base64 data URL
                            reader.readAsDataURL(blob);
                        });
                    }
                }
                // Overwrite the bgImageKey with the URL or base64 string for portability
                characterData.bgImageKey = exportedImage;
                return characterData;
            });

            // Filter out any nulls that might have occurred if an item wasn't found
            const exportData = (await Promise.all(exportDataPromises)).filter(Boolean);
            const jsonString = JSON.stringify(exportData, null, 2);
            compendiumDataTextarea.value = jsonString;
            compendiumDataTextarea.dataset.originalValue = jsonString;
            compendiumDataModal.classList.remove('invisible');
        });

        closeCompendiumDataModalBtn.addEventListener('click', async () => {
            let currentJson = compendiumDataTextarea.value;
            const originalJson = compendiumDataTextarea.dataset.originalValue;

            if (currentJson !== originalJson) {
                try {
                    if (currentJson.trim() === '') {
                        // Treat empty input as a reset
                        currentJson = '[]';
                    }
                    const importData = JSON.parse(currentJson);
                    if (!Array.isArray(importData)) throw new Error("Data must be an array.");

                    // Clear existing compendium items and their associated data
                    const currentCompendiumItems = Array.from(compendiumShelfInner.children);
                    for (const item of currentCompendiumItems) {
                        const character = Character.fromElement(item);
                        if (character) {
                            if (character.bgImageKey && character.bgImageKey.startsWith('indexeddb://')) {
                                await deleteImageFromIndexedDB(character.bgImageKey);
                            }
                            await deleteCharacterFromIndexedDB(character.id);
                            characterRegistry.delete(character.id);
                        }
                    }
                    compendiumShelfInner.innerHTML = '';

                    // Import new data
                    for (const charData of importData) {
                        let actualBgImageKey = charData.bgImageKey || '';
                        
                        // If the image is a base64 string, convert it back to a blob and save to IndexedDB
                        if (actualBgImageKey.startsWith('data:image/')) {
                            try {
                                const blob = await (await fetch(actualBgImageKey)).blob();
                                const newImageId = `indexeddb://${crypto.randomUUID()}`;
                                await saveImageToIndexedDB(newImageId, blob);
                                actualBgImageKey = newImageId; // The new key references IndexedDB
                            } catch (e) {
                                console.error("Error processing base64 image for IndexedDB:", e);
                                actualBgImageKey = '';
                            }
                        }
                        
                        // Use the correct object-based signature for createCharacter
                        createCharacter({
                            ...charData, // Spread all properties from the imported data object
                            bgImageKey: actualBgImageKey, // Use the potentially new image key
                            parent: compendiumShelfInner
                        }, true); // skip_save = true
                    }

                    refreshCompendiumLayout();
                    saveState(); // Save the final new state

                } catch (e) {
                    console.error("Failed to import compendium data:", e);
                    alert("Failed to import compendium data. Please check JSON format.");
                }
            }

            compendiumDataModal.classList.add('invisible');
        });

        /**
         * Fetches and imports character data from a specified JSON file.
         * @param {string} filename - The name of the JSON file to fetch.
         */
        async function fetchAndImportCharacterData(filename) {
            startLoadingAnimation();

            try {
                const response = await fetch(filename);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const jsonData = await response.json();
                const count = await importCharacterData(jsonData, filename);
                
                if (count > 0) {
                    addLogEntry(`Loaded ${count} items to compendium from ${filename}.`);
                }
            } catch (error) {
                console.error(`Error fetching or parsing ${filename}:`, error);
                alert(`Failed to load data from '${filename}'.`);
            } finally {
                // Always stop the animation, even on error.
                stopLoadingAnimation();
            }
        }

        /**
         * Imports character data into the compendium from a parsed JSON array.
         * @param {Array<Object>} data - An array of character objects to import.
         * @param {string} [source='unknown'] - Optional source of the data for logging/alerts.
         */
        function importCharacterData(data, source = 'unknown') {
            if (!Array.isArray(data)) {
                console.error(`Data from ${source} is not an array.`);
                alert(`Data format from '${source}' is incorrect.`);
                return 0;
            }

            data.forEach(charData => {
                // Use the correct object-based signature for createCharacter
                createCharacter({
                    name: charData.name || 'Unnamed Character',
                    hp: charData.hp || '10',
                    totalHp: charData.totalHp || charData.hp || '10',
                    statuses: Array.isArray(charData.statuses) ? charData.statuses : [],
                    notes: charData.notes || '',
                    bgColor: charData.bgColor || '',
                    bgImageKey: charData.bgImageKey || '',
                    initiative: charData.initiative || '',
                    initiativeBonus: charData.initiativeBonus || '',
                    parent: compendiumShelfInner,
                    challenge: charData.challenge || '' // Ensure challenge is passed on import
                }, true); // skip_save = true
            });

            refreshCompendiumLayout();
            saveState();
            console.log(`Character data imported successfully from ${source}!`);
            return data.length; // Return the number of items imported
        }

        // Event listener for the DND 5e button
        dnd5eImportBtn.addEventListener('click', () => fetchAndImportCharacterData('dnd_5e.json'));

        // Event listener for the PF2e button
        pf2eImportBtn.addEventListener('click', () => fetchAndImportCharacterData('pf2e_core.json'));


        // --- Button & Keyboard Logic ---
        rollInitiativesButton.addEventListener('click', rollInitiatives);
        lastTurnButton.addEventListener('click', () => {
            const lastItem = shelf.querySelector('.draggable:last-child');
            if(lastItem) {
                shelf.insertBefore(lastItem, shelf.firstChild);
                if (lastItem.id.startsWith('turn-marker')) {
                    const counter = lastItem.querySelector('.turn-counter');
                    let currentTurn = parseInt(counter.textContent, 10);
                    if (!isNaN(currentTurn) && currentTurn > 1) counter.textContent = currentTurn - 1;
                }
                saveState();
            }
        });

        moveButton.addEventListener('click', () => {
            const firstItem = shelf.querySelector('.draggable');
            if(firstItem) {
                shelf.appendChild(firstItem);
                if (firstItem.id.startsWith('turn-marker')) {
                    const counter = firstItem.querySelector('.turn-counter');
                    let currentTurn = parseInt(counter.textContent, 10);
                    counter.textContent = isNaN(currentTurn) ? 1 : currentTurn + 1;
                }
                saveState();
            }
        });

        function handleAddCharacter() {
            // Look for any highlighted characters in the compendium.
            const selectedCompendiumChars = Array.from(compendiumShelfInner.querySelectorAll('.highlighted.character-card'));

            if (selectedCompendiumChars.length > 0) {
                // If there are selections, add a copy of each to the main initiative shelf.
                selectedCompendiumChars.forEach(compendiumChar => {
                    const characterToCopy = Character.fromElement(compendiumChar);
                    if (characterToCopy) {
                        // Use the shared helper function to create a serialized copy.
                        duplicateCharacter(characterToCopy, shelf);
                    }
                });
            } else {
                // If nothing is highlighted in the compendium, add a new blank character.
                createCharacter({ parent: shelf });
            }
        }

        addButton.addEventListener('click', handleAddCharacter);


        removeButton.addEventListener('click', async () => {
            const highlightedItems = document.querySelectorAll('.highlighted');
            for (const item of highlightedItems) {
                const wasInCompendium = item.parentElement.id === 'compendium-shelf-inner';

                // Delete from IndexedDB if it's a character
                if (item.classList.contains('character-card')) {
                    await deleteCharacterFromIndexedDB(item.id);
                    // Also delete associated image if it was stored in IndexedDB
                    if (item.dataset.bgImageKey && item.dataset.bgImageKey.startsWith('indexeddb://')) {
                        await deleteImageFromIndexedDB(item.dataset.bgImageKey);
                    }
                }
                // For turn markers, only delete from localStorage
                if (item.id.startsWith('turn-marker')) {
                    localStorage.removeItem(item.id);
                }

                item.remove();
                if (wasInCompendium) {
                    refreshCompendiumLayout();
                }
            }
            updateActionButtonsState();
            saveState(); // Save state after deletion (important for order persistence)
        });

        /**
         * Creates a duplicate of a character instance on a specified parent container.
         * Handles name serialization and assigns a new background color.
         * @param {Character} characterToCopy - The class instance of the character to duplicate.
         * @param {HTMLElement} targetParent - The container to add the new character to (e.g., shelf or compendiumShelfInner).
         */
        function duplicateCharacter(characterToCopy, targetParent) {
            if (!characterToCopy || !targetParent) return;

            const originalName = characterToCopy.name;
            let newName = originalName;
            let insertionTarget = null; // The element to insert the copy after.

            // Only serialize the name if it's not empty. This fixes Bug 1.
            if (originalName.trim() !== '') {
                const nameMatch = originalName.match(/(.+) (\d+)$/);
                const baseName = nameMatch ? nameMatch[1].trim() : originalName;
                
                // Scan the target shelf to find the highest existing number for this name.
                const allCharactersOnTargetShelf = Array.from(targetParent.querySelectorAll('.character-card'));
                let highestNumberedCharEl = null;
                let highestNumber = 0;

                allCharactersOnTargetShelf.forEach(charEl => {
                    const char = Character.fromElement(charEl);
                    if (char && char.name.startsWith(baseName)) {
                        const charMatch = char.name.match(/(\d+)$/);
                        const currentNum = charMatch ? parseInt(charMatch[1], 10) : (char.name === baseName ? 1 : 0);
                        if (currentNum > highestNumber) {
                            highestNumber = currentNum;
                            highestNumberedCharEl = charEl;
                        }
                    }
                });
                
                insertionTarget = highestNumberedCharEl;
                newName = `${baseName} ${highestNumber + 1}`;
            }

            // Get a clean data object. This fixes the data inheritance bug.
            const characterDataToCopy = characterToCopy.toJSON();
            // Delete the bgColor so the constructor assigns a new one. This fixes Bug 2.
            delete characterDataToCopy.bgColor;

            // Create the new character with all the correct data.
            createCharacter({
                ...characterDataToCopy,
                name: newName,
                parent: targetParent,
                insertionElement: insertionTarget
            });
        }

        copyButton.addEventListener('click', () => {
            const originals = document.querySelectorAll('.highlighted');
            if (originals.length === 0) return;

            originals.forEach(original => {
                const characterToCopy = Character.fromElement(original);
                const parentShelf = original.closest('#shelf-items, #compendium-shelf-inner');
                
                // The helper function now contains all the complex logic.
                duplicateCharacter(characterToCopy, parentShelf);
            });
        });

        hideHpButton.addEventListener('click', () => {
            isHpHidden = !isHpHidden;
            updateAllCharacterHpDisplay();
            if (isHpHidden) {
                hideHpButton.textContent = 'Show HP';
                hideHpButton.classList.remove('bg-gray-600', 'hover:bg-gray-700', 'focus:ring-gray-300');
                hideHpButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700', 'focus:ring-cyan-300');
            } else {
                hideHpButton.textContent = 'Hide HP';
                hideHpButton.classList.add('bg-gray-600', 'hover:bg-gray-700', 'focus:ring-gray-300');
                hideHpButton.classList.remove('bg-cyan-600', 'hover:bg-cyan-700', 'focus:ring-cyan-300');
            }
            saveState();
        });

        clearStatusesButton.addEventListener('click', async () => { 
            for (const item of document.querySelectorAll('.highlighted')) {
                const character = Character.fromElement(item);
                if (character) {
                    character.statuses = [];
                    await character.render(); 
                }
            }
            saveState();
        });

        clearAllDataButton.addEventListener('click', async () => {
            // Clear localStorage entries
            localStorage.clear();

            // Clear IndexedDB object stores
            if (db) {
                const transaction = db.transaction([IMAGE_STORE_NAME, CHARACTER_STORE_NAME], 'readwrite');
                const imageStore = transaction.objectStore(IMAGE_STORE_NAME);
                const characterStore = transaction.objectStore(CHARACTER_STORE_NAME);
                
                await new Promise((resolve, reject) => {
                    const imgClearRequest = imageStore.clear();
                    imgClearRequest.onsuccess = () => {
                        const charClearRequest = characterStore.clear();
                        charClearRequest.onsuccess = () => resolve();
                        charClearRequest.onerror = (event) => reject(event.target.error);
                    };
                    imgClearRequest.onerror = (event) => reject(event.target.error);
                }).catch(e => console.error("Failed to clear IndexedDB stores:", e));
            }
            shelf.innerHTML = '';
            compendiumShelfInner.innerHTML = '';
            logDisplay.innerHTML = '';
            await initializeApp(); // Re-initialize the app to default state
        });

        compendiumHandle.addEventListener('click', () => {
            document.body.classList.toggle('compendium-open');
        });

        compendiumSearch.addEventListener('input',() => {
            refreshCompendiumLayout(applyFilters=true)
        });
        minCrInput.addEventListener('input',() => {
            refreshCompendiumLayout(applyFilters=true)
        });
        maxCrInput.addEventListener('input',() => {
            refreshCompendiumLayout(applyFilters=true)
        });

        let isMouseOverCompendium = false;
        compendiumContainer.addEventListener('mouseenter', () => { isMouseOverCompendium = true; });
        compendiumContainer.addEventListener('mouseleave', () => { isMouseOverCompendium = false; });

        compendiumShelf.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY > 0) {
                cycleCompendiumHighlight('down');
            } else {
                cycleCompendiumHighlight('up');
            }
        });

        // NEW: Log Handle listener
        logHandle.addEventListener('click', () => {
            document.body.classList.toggle('log-open');
            saveState(); // Save the new open/closed state
        });
        
        // Event listener for the log input (refactored to use helper)
        logInput.addEventListener('keydown', (e) => {
            const isHistoryNavigation = e.key === 'ArrowUp' || e.key === 'ArrowDown';

            if (isHistoryNavigation) {
                e.preventDefault();
                if (logHistoryIndex < logInputHistory.length - 1) logHistoryIndex++;
                else logHistoryIndex = -1; // Go to current input after history.
                
                logInput.value = (logHistoryIndex >= 0) ? logInputHistory[logInputHistory.length - 1 - logHistoryIndex] : '';
                logInput.focus();
                setTimeout(() => logInput.setSelectionRange(logInput.value.length, logInput.value.length), 0);
                return;
            }

            logHistoryIndex = -1;

            if (e.key === 'Enter' && logInput.value.trim() !== '') {
                e.preventDefault();
                const inputText = logInput.value.trim();

                if (inputText && logInputHistory[logInputHistory.length - 1] !== inputText) {
                    logInputHistory.push(inputText);
                    if (logInputHistory.length > 20) logInputHistory.shift();
                }
                logHistoryIndex = -1;

                if (inputText.toLowerCase().startsWith('/roll ')) {
                    const diceExpression = inputText.substring(6).trim();
                    const result = parseAndRoll(diceExpression);
                    if (result !== null) {
                        const finalLogMessage = `Rolled <strong>${result.expression}</strong> &rarr; <strong class="text-xl text-yellow-300">${result.total}</strong>` + 
                                            (result.breakdown ? `<br><span class="text-gray-400 text-xs">${result.breakdown}</span>` : '');
                        addLogEntry(finalLogMessage, true);
                    }
                } else {
                    addLogEntry(inputText);
                }

                logInput.value = '';
            }
        });

        d20RollBtn.addEventListener('click', () => rollD20());

        let isSelecting = false;
        let startX, startY;
        let selectionContainer = null; // Declare here to be accessible globally in this scope

        document.body.addEventListener('mousedown', (e) => {
            // Block selection if clicking on specific interactive elements like cards, buttons, or modals.
            if (e.target.closest('.draggable, button, input, #context-menu, #status-modal, #notes-modal, #compendium-data-modal, #log-container')) {
                return;
            }
            
            // Check if the click is within one of our valid selection areas.
            const shelfContainer = e.target.closest('#shelf-items');
            const compendiumContainerWrapper = e.target.closest('#compendium-shelf-inner-wrapper');

            if (shelfContainer) {
                // We are selecting in the main initiative row.
                selectionContainer = shelfContainer;
            } else if (compendiumContainerWrapper) {
                // We are selecting in the compendium.
                selectionContainer = compendiumContainerWrapper.querySelector('#compendium-shelf-inner');
            } else {
                // The click was not in a valid area (e.g., page background), so do nothing.
                selectionContainer = null;
                return;
            }

            // If we're in a valid area, prevent default browser behavior and start the selection.
            e.preventDefault();
            isSelecting = true;
            startX = e.clientX; startY = e.clientY;
            Object.assign(selectionBox.style, { left: `${startX}px`, top: `${startY}px`, width: '0px', height: '0px', display: 'block' });
            
            // If not holding shift, clear all previous selections before starting a new one.
            if (!e.shiftKey) {
                document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
                updateActionButtonsState();
            }
        });
        window.addEventListener('mousemove', (e) => {
            // Only run if we are actively selecting in a valid container.
            if (!isSelecting || !selectionContainer) return;

            e.preventDefault();
            const currentX = e.clientX, currentY = e.clientY;
            const width = Math.abs(currentX - startX), height = Math.abs(currentY - startY);
            const left = Math.min(currentX, startX), top = Math.min(currentY, startY);
            Object.assign(selectionBox.style, { width: `${width}px`, height: `${height}px`, left: `${left}px`, top: `${top}px` });
            
            const boxRect = selectionBox.getBoundingClientRect();
            
            // Only query for characters within the active container.
            selectionContainer.querySelectorAll('.draggable.character-card').forEach(item => {
                // Do not select items hidden by the compendium search filter.
                if (item.style.display === 'none') return; 

                const itemRect = item.getBoundingClientRect();
                const isIntersecting = !(boxRect.right < itemRect.left || boxRect.left > itemRect.right || boxRect.bottom < itemRect.top || boxRect.top > itemRect.bottom);
                
                if (isIntersecting) {
                    item.classList.add('highlighted');
                } else if (!e.shiftKey) { // Only deselect if not holding shift.
                    item.classList.remove('highlighted');
                }
            });

            updateActionButtonsState();
        });
        window.addEventListener('mouseup', () => {
            if (isSelecting) {
                isSelecting = false;
                selectionBox.style.display = 'none';
                selectionContainer = null; 
            }
        });

        document.addEventListener('keydown', (event) => {
            const isNotesModalOpen = !notesModal.classList.contains('invisible');
            const isStatusModalOpen = !statusModal.classList.contains('invisible');
            const isContextMenuOpen = !contextMenu.classList.contains('invisible');
            const activeElementIsEditable = document.activeElement.getAttribute('contenteditable') === 'true' || ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);

            if (event.ctrlKey || event.metaKey || event.altKey) {
                return;
            }

            if (event.key === 'Escape') {
                if (isNotesModalOpen) return closeNotesModal();
                if (isStatusModalOpen) return statusModal.classList.add('invisible');
                if (isContextMenuOpen) return contextMenu.classList.add('invisible');
                document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                updateActionButtonsState();
                refreshCompendiumLayout();
                return;
            }

            // Check for the status modal's shortcuts BEFORE checking for other active inputs.
            if (isStatusModalOpen) {
                if (event.code.startsWith('Digit')) {
                    event.preventDefault();
                    const keyNumber = event.code === 'Digit0' ? 9 : parseInt(event.code.slice(-1)) - 1;
                    if (symbolGrid.children[keyNumber]) symbolGrid.children[keyNumber].click();
                }
                return; // Stop processing other keys if the status modal is open
            }

            if (isNotesModalOpen && event.code === 'KeyN' && document.activeElement !== document.getElementById('notes-edit-content')) {
                event.preventDefault();
                return closeNotesModal();
            }
            if (isNotesModalOpen || isStatusModalOpen || isContextMenuOpen || activeElementIsEditable) return;

            if (isMouseOverCompendium) {
                if (event.code === 'ArrowDown') {
                    event.preventDefault();
                    cycleCompendiumHighlight('down');
                } else if (event.code === 'ArrowUp') {
                    event.preventDefault();
                    cycleCompendiumHighlight('up');
                }
            }

            switch (event.code) {
                case 'Space': event.preventDefault(); moveButton.click(); break;
                case 'Backspace': event.preventDefault(); lastTurnButton.click(); break;
                case 'KeyA': event.preventDefault(); handleAddCharacter(); break; // Use handleAddCharacter
                case 'KeyS': event.preventDefault(); if (!addStatusButton.disabled) handleStatusModalToggle(); break;
                case 'KeyC': event.preventDefault(); if (!copyButton.disabled) copyButton.click(); break;
                case 'KeyX': event.preventDefault(); if (!clearStatusesButton.disabled) clearStatusesButton.click(); break;
                case 'KeyN': event.preventDefault(); if (!notesButton.disabled) openNotesModal(); break;
                case 'Delete': event.preventDefault(); if (!removeButton.disabled) removeButton.click(); break;
                case 'KeyR':
                    event.preventDefault();
                    rollD20();
                    // If the log panel is closed, open it to show the result.
                    if (!document.body.classList.contains('log-open')) {
                        logHandle.click();
                    }
                    break;
            }
        });

        window.addEventListener('click', (e) => {
            if (!contextMenu.classList.contains('invisible') && !contextMenu.contains(e.target) && !e.target.closest('.draggable')) {
                contextMenu.classList.add('invisible');
            }
        });

        async function initializeDefaultScene() {
            // Clear the shelves, but not all of localStorage
            shelf.innerHTML = '';
            compendiumShelfInner.innerHTML = '';

            characterRegistry.clear(); // Clear registry too for a fresh start.
            colorIndex = 0;
            const goblinImageUrl = 'https://www.dndbeyond.com/avatars/thumbnails/30783/955/1000/1000/638062024584880857.png';
            const goblinNotes = `<p><strong>Goblin</strong><br><em>Small Humanoid (Goblinoid), Neutral Evil</em></p><hr><p><strong>Armor Class</strong> 15 (leather armor, shield)<br><strong>Hit Points</strong> 7 (2d6)<br><strong>Speed</strong> 30 ft.</p><hr><p><strong>STR</strong> 8 (-1) | <strong>DEX</strong> 14 (+2) | <strong>CON</strong> 10 (+0) | <strong>INT</strong> 10 (+0) | <strong>WIS</strong> 8 (-1) | <strong>CHA</strong> 8 (-1)</p><hr><p><strong>Skills</strong> Stealth +6<br><strong>Senses</strong> Darkvision 60 ft., Passive Perception 9<br><strong>Languages</strong> Common, Goblin<br><strong>Challenge</strong> 1/4 (50 XP) | <strong>Proficiency Bonus</strong> +2</p><hr><p><strong><em>Nimble Escape.</em></strong> The goblin can take the Disengage or Hide action as a bonus action on each of its turns.</p><p><strong>Actions</strong><br><strong><em>Scimitar.</em></strong> <em>Melee Weapon Attack:</em> +4 to hit, reach 5 ft., one target. <em>Hit:</em> 5 (1d6 + 2) slashing damage.<br><strong><em>Shortbow.</em></strong> <em>Ranged Weapon Attack:</em> +4 to hit, range 80/320 ft., one target. <em>Hit:</em> 5 (1d6 + 2) piercing damage.</p>`;
            const hectorImageUrl = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQg4hykDiVWaLpgPyX2boVONNK76mugungN3A&s';

            createTurnMarker(null, '1', true);

            createCharacter({ name: 'Goblin 1', hp: 7, totalHp: 7, notes: goblinNotes, bgImageKey: goblinImageUrl, initiativeBonus: 2, initiative: 16, challenge: '1/4' }, true);
            createCharacter({ name: 'Goblin 2', hp: 7, totalHp: 7, notes: goblinNotes, bgImageKey: goblinImageUrl, initiativeBonus: 2, initiative: 14, challenge: '1/4' }, true);
            createCharacter({ name: 'Goblin 3', hp: 4, totalHp: 7, statuses: ['â¤ï¸â€ðŸ©¹'], notes: goblinNotes, bgImageKey: goblinImageUrl, initiativeBonus: 2, initiative: 9, challenge: '1/4' }, true);
            createCharacter({ name: 'Hector the Well-Endowed', hp: 18, totalHp: 18, statuses: ['âš¡ï¸'], bgImageKey: hectorImageUrl, initiativeBonus: -1, initiative: 5, challenge: '1' }, true);
            createCharacter({ name: 'Goblin', hp: 7, totalHp: 7, notes: goblinNotes, bgImageKey: goblinImageUrl, parent: compendiumShelfInner, initiativeBonus: 2, challenge: '1/4' }, true);
            
            addLogEntry("Welcome to the Initiative Tracker! (hint, try typing /roll 1d20, or /roll 2d20kh1 for advantage)");

            await saveState();
            return { initiativeCount: 5, compendiumCount: 1 };
        }

        async function initializeApp() {
            populateColorMenu();
            await openIndexedDB();

            startLoadingAnimation();
            
            try {
                const { initiativeCount, compendiumCount } = await loadState();

                if (initiativeCount === 0 && compendiumCount === 0) {
                    const defaultCounts = await initializeDefaultScene();
                    addLogEntry(`Loaded ${defaultCounts.initiativeCount + defaultCounts.compendiumCount} default items: ${defaultCounts.initiativeCount} to Initiative, ${defaultCounts.compendiumCount} to Compendium.`);
                } else {
                    addLogEntry(`Loaded ${initiativeCount} items to Initiative and ${compendiumCount} items to Compendium.`);
                }
            } catch (error) {
                console.error("An error occurred during app initialization:", error);
                addLogEntry("Error during initialization. State may be incomplete.");
            } finally {
                // This block runs after all loading is complete.
                stopLoadingAnimation();
                updateAllCharacterHpDisplay();
                refreshCompendiumLayout(); // This function causes the highlight.

                // Explicitly find and un-highlight any selected item in the compendium on load.
                const highlightedCompendiumItem = compendiumShelfInner.querySelector('.highlighted');
                if (highlightedCompendiumItem) {
                    highlightedCompendiumItem.classList.remove('highlighted');
                    // Ensure the action buttons are correctly disabled since nothing is selected now.
                    updateActionButtonsState(); 
                }
            }
        }

        initializeApp();

    </script>
</body>
</html>
