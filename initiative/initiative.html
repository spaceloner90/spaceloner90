<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid of Elements</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap">
    <style>
        /* Apply border-box sizing to all elements for more predictable layouts */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            user-select: none; /* Prevent text selection during drag operations */
        }
        /* Style for the contenteditable fields to give user feedback */
        [contenteditable]:focus {
            outline: none;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        [contenteditable] {
            cursor: text;
            user-select: text; /* Allow text selection inside editable fields */
        }
        /* CSS to create placeholder text for the name field */
        [data-placeholder]:empty::before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.6); /* Lighter color for hint text */
            pointer-events: none; /* Allow clicks to focus the element */
        }
        /* Visual feedback for the item being dragged */
        .dragging {
            opacity: 0.5;
            border: 2px dashed #60a5fa; /* A blue dash to stand out */
        }
        /* Make items draggable and add base transition */
        .draggable {
            cursor: grab;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative; 
            background-size: cover;
            background-position: center;
        }
        .draggable:active {
            cursor: grabbing;
        }
        /* Apply hover effect ONLY to non-highlighted items */
        .draggable:not(.highlighted):hover {
            transform: translateY(-4px);
        }

        /* --- Animation for the Highlight --- */
        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.3);
            }
            100% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
        }

        /* --- New Animation for Pop-in Effect --- */
        @keyframes pop-in {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .pop-in-animation {
            animation: pop-in 0.3s ease-out forwards;
        }

        /* Style for the highlighted/selected item */
        .highlighted {
            transform: scale(1.05) translateY(-8px); /* Slightly larger and more lifted */
            animation: pulse-border 1.5s infinite; /* Apply the new animation */
        }
        
        /* New style for highlighting selected statuses in the modal */
        .symbol-selected {
            background-color: #dbeafe; /* A light blue background */
            border: 2px solid #60a5fa; /* A slightly darker blue border */
        }

        /* Style for the drag-to-select box */
        #selection-box {
            position: absolute;
            border: 2px solid #60a5fa;
            background-color: rgba(59, 130, 246, 0.2);
            pointer-events: none; /* So it doesn't interfere with mouse events */
            z-index: 9999;
        }

        /* Style for the custom color context menu */
        #context-menu {
            position: absolute;
            z-index: 10000;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 8px;
            width: 200px;
        }
        
        /* Add a text shadow for readability over any background */
        .text-readable {
            text-shadow: 0 1px 3px rgba(0,0,0,0.6);
        }

        /* Styles for the confirmation modal */
        /* REMOVED .confirm-modal-overlay, .confirm-modal-content, .confirm-modal-buttons */
    </style>
</head>
<body class="bg-gray-100">

    <!-- This div is for the drag-to-select feature -->
    <div id="selection-box" style="display: none;"></div>
    
    <!-- Custom context menu for changing colors and images -->
    <div id="context-menu" class="hidden">
        <div class="space-y-2">
            <div>
                <label class="block text-sm font-medium text-gray-700">Image URL</label>
                <div class="mt-1 flex rounded-md shadow-sm">
                    <input type="text" id="image-url-input" class="focus:ring-indigo-500 focus:border-indigo-500 flex-1 block w-full rounded-none rounded-l-md sm:text-sm border-gray-300 p-1">
                    <button id="apply-url-btn" class="inline-flex items-center px-3 rounded-r-md border border-l-0 border-gray-300 bg-gray-50 text-gray-500 text-sm">Apply</button>
                </div>
            </div>
            <div>
                <label for="image-file-input" class="block text-sm font-medium text-gray-700">Or Upload File</label>
                <input type="file" id="image-file-input" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100"/>
            </div>
            <div class="border-t border-gray-200 pt-2">
                 <p class="text-sm font-medium text-gray-700 mb-1">Color</p>
                 <div id="color-grid" class="grid grid-cols-6 gap-2">
                    <!-- Color swatches will be populated here by JavaScript -->
                </div>
            </div>
        </div>
    </div>


    <!-- Main container for the scene -->
    <div class="w-full max-w-6xl mx-auto px-4 py-8">

        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Vick's Initiative Tracker</h1>

        <!-- Container for the elements, now a wrapping flex container -->
        <div id="shelf-items" class="flex flex-wrap justify-center items-start gap-4 min-h-80 p-4 bg-white rounded-lg shadow-inner">
            
            <!-- The Black Bar / Turn Marker is loaded dynamically -->

            <!-- Elements will be populated by JavaScript -->
        </div>

        <!-- Button Container -->
        <div class="mt-8 text-center space-y-4">
            <div class="space-x-4">
                <button id="move-item-btn" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                    Next Turn (SPACE)
                </button>
                 <button id="last-turn-btn" class="bg-amber-500 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-amber-600 focus:outline-none focus:ring-4 focus:ring-amber-300 transition-all duration-200">
                    Last Turn (BACKSPACE)
                </button>
                <button id="add-item-btn" class="bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-200">
                    Add Character (A)
                </button>
            </div>
            <!-- Second row of buttons for actions on highlighted items -->
            <div id="action-buttons" class="space-x-4">
                <button id="remove-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Remove (DELETE)
                </button>
                <button id="copy-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Copy (C)
                </button>
                <button id="add-status-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Add Status (S)
                </button>
                <button id="clear-statuses-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Clear Statuses (X)
                </button>
            </div>
            <!-- New row for clear all data button -->
            <div class="mt-4">
                <button id="clear-all-data-btn" class="bg-red-800 text-white font-bold py-2 px-5 rounded-lg shadow-md hover:bg-red-900 focus:outline-none focus:ring-4 focus:ring-red-300 transition-all duration-200">
                    Clear All Data
                </button>
            </div>
        </div>
    </div>

    <!-- Status Symbol Modal -->
    <div id="status-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-800">Select a Status Effect</h2>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <div id="symbol-grid" class="grid grid-cols-5 gap-4">
                <!-- Symbols will be populated here by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Confirmation Modal for Clear All Data (REMOVED FROM HTML) -->


    <!-- JavaScript Logic -->
    <script>
        // Get the buttons and containers
        const lastTurnButton = document.getElementById('last-turn-btn');
        const moveButton = document.getElementById('move-item-btn');
        const addButton = document.getElementById('add-item-btn');
        const removeButton = document.getElementById('remove-btn');
        const copyButton = document.getElementById('copy-btn');
        const addStatusButton = document.getElementById('add-status-btn');
        const clearStatusesButton = document.getElementById('clear-statuses-btn');
        const shelf = document.getElementById('shelf-items');
        const statusModal = document.getElementById('status-modal');
        const closeModalButton = document.getElementById('close-modal-btn');
        const symbolGrid = document.getElementById('symbol-grid');
        const selectionBox = document.getElementById('selection-box');
        const contextMenu = document.getElementById('context-menu');
        const colorGrid = document.getElementById('color-grid');
        const imageUrlInput = document.getElementById('image-url-input');
        const applyUrlButton = document.getElementById('apply-url-btn');
        const imageFileInput = document.getElementById('image-file-input');
        const clearAllDataButton = document.getElementById('clear-all-data-btn'); // New button reference

        // --- Data ---
        const colorPalette = [
            'bg-red-500', 'bg-orange-500', 'bg-amber-500', 'bg-yellow-500', 'bg-lime-500', 'bg-green-500', 
            'bg-emerald-500', 'bg-teal-500', 'bg-cyan-500', 'bg-sky-500', 'bg-blue-500', 'bg-indigo-500',
            'bg-violet-500', 'bg-purple-500', 'bg-fuchsia-500', 'bg-pink-500', 'bg-rose-500', 'bg-slate-500'
        ];
        let colorIndex = 0; // To cycle through colors for new characters
        
        const statusSymbols = ['â˜ ï¸', 'ðŸ”¥', 'â„ï¸', 'âš¡ï¸', 'ðŸ›¡ï¸', 'âš”ï¸', 'â¤ï¸â€ðŸ©¹', 'ðŸ˜µ', 'ðŸ¤¢', 'â“', 'ðŸ’ª', 'ðŸŽ¯'];

        // --- IndexedDB Setup ---
        let db;
        const DB_NAME = 'initiativeTrackerDB';
        const DB_VERSION = 1;
        const IMAGE_STORE_NAME = 'images';

        function openIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (!db.objectStoreNames.contains(IMAGE_STORE_NAME)) {
                        db.createObjectStore(IMAGE_STORE_NAME);
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('IndexedDB opened successfully');
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        async function saveImageToIndexedDB(id, blob) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.put(blob, id); // Store blob with the generated ID

                request.onsuccess = () => {
                    resolve();
                };

                request.onerror = (event) => {
                    console.error('Error saving image to IndexedDB:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        async function loadImageFromIndexedDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.get(id);

                request.onsuccess = (event) => {
                    resolve(event.target.result); // This will be the Blob
                };

                request.onerror = (event) => {
                    console.error('Error loading image from IndexedDB:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        async function deleteImageFromIndexedDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.delete(id);

                request.onsuccess = () => {
                    resolve();
                };

                request.onerror = (event) => {
                    console.error('Error deleting image from IndexedDB:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        // Helper function to convert base64 to Blob
        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        }


        // --- Cookie Functions for Persistence ---
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "")  + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for(let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function saveStateToCookie() {
            const state = [];
            Array.from(shelf.children).forEach(item => {
                if (item.classList.contains('bg-black')) { // It's the turn marker
                    state.push({ type: 'turnMarker' });
                } else { // It's a character card
                    const nameSpan = item.querySelector('.font-bold.text-lg');
                    const hpSpan = item.querySelector('.text-2xl.font-mono');
                    const statusContainer = item.querySelector('.status-container');

                    const statuses = Array.from(statusContainer.querySelectorAll('span')).map(s => s.textContent);
                    const bgColorClass = Array.from(item.classList).find(cls => colorPalette.includes(cls));
                    
                    let bgImage = item.style.backgroundImage;
                    let indexedDbImageId = item.dataset.indexedDbImageId || ''; // Get the stored IndexedDB ID if it exists

                    // Prioritize IndexedDB ID for saving
                    if (indexedDbImageId) {
                        bgImage = `indexeddb://${indexedDbImageId}`; // Store a reference to IndexedDB
                    } else if (bgImage) {
                         // Extract the raw URL from url("...") for external images
                        const urlMatch = bgImage.match(/^url\(['"]?(.*?)['"]?\)$/);
                        bgImage = urlMatch ? urlMatch[1] : '';
                    }

                    state.push({
                        type: 'character',
                        name: nameSpan ? nameSpan.textContent.trim() : '',
                        hp: hpSpan ? hpSpan.textContent.trim() : '',
                        statuses: statuses,
                        bgColor: bgColorClass || '',
                        bgImage: bgImage || '' // Ensure it's an empty string if null/undefined
                    });
                }
            });
            setCookie('initiativeTrackerState', JSON.stringify(state), 365); // Save for 1 year
            console.log('State saved to cookie.');
        }

        async function loadStateFromCookie() {
            const savedState = getCookie('initiativeTrackerState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    shelf.innerHTML = ''; // Clear existing elements

                    // Use a for...of loop to await async operations within the loop
                    for (const itemData of state) {
                        if (itemData.type === 'turnMarker') {
                            createTurnMarker();
                        } else if (itemData.type === 'character') {
                            let actualBackgroundImage = itemData.bgImage;
                            let indexedDbImageId = '';

                            if (itemData.bgImage.startsWith('indexeddb://')) {
                                indexedDbImageId = itemData.bgImage.substring('indexeddb://'.length);
                                try {
                                    const blob = await loadImageFromIndexedDB(indexedDbImageId);
                                    if (blob) {
                                        actualBackgroundImage = URL.createObjectURL(blob);
                                    } else {
                                        console.warn(`Image with ID ${indexedDbImageId} not found in IndexedDB.`);
                                        actualBackgroundImage = ''; // Fallback if image not found
                                    }
                                } catch (e) {
                                    console.error(`Failed to load image from IndexedDB for ID ${indexedDbImageId}:`, e);
                                    actualBackgroundImage = '';
                                }
                            }
                            
                            const characterOptions = {
                                backgroundColorClass: itemData.bgColor, 
                                // Pass the raw ID if it's an IndexedDB image, otherwise the URL
                                backgroundImage: itemData.bgImage.startsWith('indexeddb://') ? itemData.bgImage : actualBackgroundImage 
                            };
                            const characterElement = createCharacter(
                                itemData.name, 
                                itemData.hp, 
                                itemData.statuses, 
                                characterOptions
                            );
                            // If it was an IndexedDB image, the createCharacter function already set the dataset.indexedDbImageId
                            // and objectUrl internally based on the 'indexeddb://ID' format.
                        }
                    }
                    console.log('State loaded from cookie.');
                    updateActionButtonsState(); // Update button states after loading
                    return true;
                } catch (e) {
                    console.error("Error parsing saved state from cookie:", e);
                    return false;
                }
            }
            return false;
        }


        // --- Core Functions for Item States ---

        function updateActionButtonsState() {
            const selectedItems = document.querySelectorAll('.highlighted');
            const buttonsToUpdate = [removeButton, copyButton, addStatusButton, clearStatusesButton];
            
            if (selectedItems.length > 0) {
                buttonsToUpdate.forEach(button => {
                    button.disabled = false;
                    button.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                });
                removeButton.classList.add('bg-red-600', 'hover:bg-red-700', 'focus:ring-4', 'focus:ring-red-300');
                copyButton.classList.add('bg-teal-600', 'hover:bg-teal-700', 'focus:ring-4', 'focus:ring-teal-300');
                addStatusButton.classList.add('bg-purple-600', 'hover:bg-purple-700', 'focus:ring-4', 'focus:ring-purple-300');
                clearStatusesButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-4', 'focus:ring-yellow-300');

            } else {
                buttonsToUpdate.forEach(button => {
                    button.disabled = true;
                    button.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                    button.classList.remove(
                        'bg-red-600', 'hover:bg-red-700', 'focus:ring-red-300',
                        'bg-teal-600', 'hover:bg-teal-700', 'focus:ring-teal-300',
                        'bg-purple-600', 'hover:bg-purple-700', 'focus:ring-purple-300',
                        'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-300',
                        'focus:ring-4'
                    );
                });
            }
        }

        function initializeDraggable(item) {
            item.setAttribute('draggable', true);
            item.addEventListener('dragstart', () => {
                if (!item.classList.contains('highlighted')) {
                    document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                    item.classList.add('highlighted');
                }
                setTimeout(() => item.classList.add('dragging'), 0)
            });
            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                saveStateToCookie(); // Save state after drag and drop
            });
        }

        function initializeSelectable(item) {
            // Only make character cards selectable, not the turn marker
            if (item.classList.contains('bg-black')) return;

            item.addEventListener('click', (event) => {
                // Modified: removed condition `isClickOnIcon` to prevent status icons from being tap targets for dismissal
                if (event.target.getAttribute('contenteditable') === 'true') return;
                
                if (event.shiftKey) {
                    item.classList.toggle('highlighted');
                } else {
                    const isAlreadySelected = item.classList.contains('highlighted');
                    const selectedCount = document.querySelectorAll('.highlighted').length;

                    if (isAlreadySelected && selectedCount > 1) {
                         // If already selected and multiple items are selected, don't deselect others
                         // This allows for individual interaction without losing group selection immediately
                         return;
                    }
                    
                    document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                    if (!isAlreadySelected) item.classList.add('highlighted');
                }
                updateActionButtonsState();
            });
        }

        function initializeHpField(hpSpan) {
            hpSpan.addEventListener('focus', () => {
                hpSpan.dataset.originalHp = hpSpan.textContent.trim();
            });

            const resolveHp = () => {
                const originalHp = parseInt(hpSpan.dataset.originalHp, 10);
                const expression = hpSpan.textContent.trim();
                if (isNaN(originalHp)) return; // Ensure original HP is a number

                let newHp;
                try {
                    // Sanitize the expression: allow digits, +, -, *, /, and spaces.
                    // This is a simplified regex; for complex calculators, a full parser is needed.
                    const sanitizedExpression = expression.replace(/\s/g, ''); // Remove all spaces
                    
                    // Allow basic arithmetic: digits, +, -, *, /
                    // If you only want +, -, restrict this regex.
                    const validCharsRegex = /^[\d+\-*/.]+$/; // Added / and . for decimals/division
                    if (!validCharsRegex.test(sanitizedExpression)) {
                        throw new Error("Invalid characters or format in HP expression.");
                    }

                    // Use the Function constructor for safe evaluation of simple arithmetic.
                    // Wrap the expression in parentheses to ensure it's evaluated as a whole.
                    // This is generally safer than 'eval()' because it runs in its own scope.
                    newHp = new Function('return (' + sanitizedExpression + ')')();

                    // Ensure newHp is a finite number
                    if (!Number.isFinite(newHp)) {
                        throw new Error("Invalid calculation result.");
                    }

                } catch (error) {
                    console.error("HP calculation error:", error);
                    newHp = originalHp; // Revert to original HP on error
                }
                hpSpan.textContent = Math.round(newHp); // Round to integer HP
                saveStateToCookie(); // Save state after HP change
            };
            
            hpSpan.addEventListener('blur', resolveHp);
            hpSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); resolveHp(); hpSpan.blur(); } 
                else if (e.key === 'Escape') { hpSpan.textContent = hpSpan.dataset.originalHp; hpSpan.blur(); }
            });

            // Handle name changes separately
            const nameSpan = hpSpan.parentElement.previousElementSibling; // Assuming HP span is under HP label, and name is sibling to HP div
            if (nameSpan && nameSpan.getAttribute('contenteditable') === 'true') {
                 nameSpan.addEventListener('blur', saveStateToCookie);
                 nameSpan.addEventListener('keydown', (e) => {
                     if (e.key === 'Enter') { e.preventDefault(); nameSpan.blur(); }
                 });
            }
        }
        
        function initializeContextMenu(item) {
            item.addEventListener('contextmenu', e => {
                e.preventDefault();
                
                // If the item is the turn marker, don't show context menu
                if (item.classList.contains('bg-black')) return;

                if (!item.classList.contains('highlighted')) {
                    document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
                    item.classList.add('highlighted');
                    updateActionButtonsState();
                }

                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.classList.remove('hidden');
            });
        }


        // No longer query all .draggable on load, as they are created dynamically
        // document.querySelectorAll('.draggable').forEach(item => {
        //     initializeDraggable(item);
        //     initializeSelectable(item);
        //     initializeContextMenu(item);
        // });

        // --- Drag & Drop Logic ---
        shelf.addEventListener('dragover', e => {
            e.preventDefault();
            const draggingItem = document.querySelector('.dragging');
            if (!draggingItem) return;

            // Pass both X and Y coordinates to the placement function
            const afterElement = getDragAfterElement(shelf, e.clientX, e.clientY);
            
            if (afterElement == null) {
                shelf.appendChild(draggingItem);
            } else {
                shelf.insertBefore(draggingItem, afterElement);
            }
        });

        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();

                // Check if the cursor is vertically within the element's bounds.
                // This is the key change to handle multiple rows correctly.
                if (y > box.top && y < box.bottom) {
                    const offset = x - box.left - box.width / 2;
                    // We are looking for an element that is to the right of the cursor (offset < 0)
                    // and is the closest one on its right.
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }
                // If not on the same vertical plane, keep the previous closest.
                return closest;

            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function createCharacter(name, hp, statuses = [], options = {}) {
            const { 
                insertionElement = null, 
                backgroundColorClass = null, 
                backgroundImage = '' // Can be a direct URL or 'indexeddb://ID'
            } = options;

            const newItem = document.createElement('div');
            
            // Assign a color from the palette, or use the one provided for loading
            const newColor = backgroundColorClass || colorPalette[colorIndex++ % colorPalette.length];
            newItem.className = `draggable ${newColor} rounded-md w-32 min-h-56 shadow-lg flex flex-col justify-between p-2 text-white`;
            
            // NEW LOGIC FOR BACKGROUND IMAGE HANDLING
            if (backgroundImage.startsWith('indexeddb://')) {
                const imageId = backgroundImage.substring('indexeddb://'.length);
                newItem.dataset.indexedDbImageId = imageId; // Store the ID on the new item
                // When character is created from a copy, we need to load the blob
                loadImageFromIndexedDB(imageId).then(blob => {
                    if (blob) {
                        const objectUrl = URL.createObjectURL(blob);
                        newItem.style.backgroundImage = `url('${objectUrl}')`;
                        newItem.dataset.objectUrl = objectUrl; // Store object URL for revoking later
                    } else {
                        console.warn(`Copied image with ID ${imageId} not found in IndexedDB.`);
                    }
                }).catch(e => {
                    console.error(`Error loading copied IndexedDB image for ID ${imageId}:`, e);
                });
            } else if (backgroundImage) { // Handles external URLs or data URLs directly passed (but not from file input)
                newItem.style.backgroundImage = `url('${backgroundImage}')`;
                // Ensure no leftover IndexedDB ID if an external URL is explicitly set
                delete newItem.dataset.indexedDbImageId;
                if (newItem.dataset.objectUrl) {
                    URL.revokeObjectURL(newItem.dataset.objectUrl);
                    delete newItem.dataset.objectUrl;
                }
            }
            
            const nameContent = name || '';
            const namePlaceholder = name ? '' : 'data-placeholder="Name"';

            newItem.innerHTML = `
                <div class="flex flex-col items-center flex-shrink-0">
                    <span contenteditable="true" class="font-bold text-lg p-1 text-center text-readable" ${namePlaceholder}>${nameContent}</span>
                    <div class="flex flex-col items-center mt-2">
                        <span class="text-xs font-semibold text-white/80 select-none text-readable">HP</span>
                        <span contenteditable="true" class="text-2xl font-mono p-1 text-readable">${hp}</span>
                    </div>
                </div>
                <div class="status-container w-full flex-grow mt-2 p-1 flex flex-wrap items-center justify-center content-start gap-2"></div>`;

            const statusContainer = newItem.querySelector('.status-container');
            statuses.forEach(symbol => {
                 const statusIcon = document.createElement('span');
                 statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-default text-readable"; // Changed cursor to default
                 // Removed click listener for statusIcon dismissal
                 statusIcon.textContent = symbol;
                 statusContainer.appendChild(statusIcon);
            });
            
            initializeHpField(newItem.querySelector('.text-2xl.font-mono'));
            initializeDraggable(newItem);
            initializeSelectable(newItem); // Character cards are selectable
            initializeContextMenu(newItem);
            
            if(insertionElement) insertionElement.after(newItem);
            else shelf.appendChild(newItem);

            newItem.classList.add('pop-in-animation');
            newItem.addEventListener('animationend', () => newItem.classList.remove('pop-in-animation'), { once: true });
            saveStateToCookie(); // Save state after a new character is created

            return newItem; // Return the created item
        }
        
        function createTurnMarker() {
            const turnMarker = document.createElement('div');
            turnMarker.className = 'draggable bg-black rounded-full w-2 h-56 shadow-lg self-center';
            initializeDraggable(turnMarker);
            // Turn marker is not selectable or does not have context menu
            shelf.appendChild(turnMarker);
        }

        // --- Modal & Menu Logic ---
        function populateSymbolModal(selectedItems) {
            symbolGrid.innerHTML = '';
            
            statusSymbols.forEach((symbol) => {
                const symbolButton = document.createElement('button');
                symbolButton.className = "relative text-3xl p-4 rounded-lg hover:bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500";
                
                const allHaveStatus = selectedItems.length > 0 && Array.from(selectedItems).every(item => 
                    Array.from(item.querySelectorAll('.status-container span')).map(s => s.textContent).includes(symbol)
                );
                
                if (allHaveStatus) symbolButton.classList.add('symbol-selected');

                symbolButton.innerHTML = `<span class="pointer-events-none">${symbol}</span><span class="absolute bottom-1 right-1 text-xs font-mono bg-gray-600 text-white rounded-sm px-1.5 py-0.5 pointer-events-none">${(statusSymbols.indexOf(symbol) + 1) % 10}</span>`;
                
                symbolButton.addEventListener('click', () => {
                    // Check if all selected items already have this status
                    if (allHaveStatus) {
                        // If all have it, remove it from all selected items
                        selectedItems.forEach(item => {
                            item.querySelectorAll('.status-container span').forEach(icon => {
                                if (icon.textContent === symbol) icon.remove();
                            });
                        });
                    } else {
                        // If not all have it, add it to those that don't
                        selectedItems.forEach(item => {
                            if (!Array.from(item.querySelectorAll('.status-container span')).map(s => s.textContent).includes(symbol)) {
                                const statusIcon = document.createElement('span');
                                statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-default text-readable"; // Changed cursor to default
                                // Removed click listener for statusIcon dismissal
                                statusIcon.textContent = symbol;
                                item.querySelector('.status-container').appendChild(statusIcon);
                            }
                        });
                    }
                    populateSymbolModal(selectedItems); // Re-populate to update selection visual
                    saveStateToCookie(); // Save state after status changes
                });
                symbolGrid.appendChild(symbolButton);
            });
        }
        
        function populateColorMenu() {
            colorGrid.innerHTML = ''; // Clear previous swatches
            colorPalette.forEach(color => {
                const swatch = document.createElement('button');
                swatch.className = `w-8 h-8 rounded-full ${color} border-2 border-white/50 hover:scale-110 transition-transform`;
                swatch.dataset.color = color;
                swatch.addEventListener('click', () => {
                    const selectedItems = document.querySelectorAll('.highlighted');
                    selectedItems.forEach(item => {
                        item.style.backgroundImage = ''; // Clear image if color is set
                        // Also clear any IndexedDB image ID
                        delete item.dataset.indexedDbImageId;
                        if (item.dataset.objectUrl) {
                            URL.revokeObjectURL(item.dataset.objectUrl);
                            delete item.dataset.objectUrl;
                        }

                        item.classList.remove(...colorPalette);
                        item.classList.add(color);
                    });
                    contextMenu.classList.add('hidden');
                    saveStateToCookie(); // Save state after color change
                });
                colorGrid.appendChild(swatch);
            });
        }
        
        function handleStatusModalToggle() {
             if (!statusModal.classList.contains('hidden')) {
                statusModal.classList.add('hidden');
            } else {
                if (!addStatusButton.disabled) {
                    const selectedItems = document.querySelectorAll('.highlighted');
                    if (selectedItems.length > 0) {
                        populateSymbolModal(selectedItems);
                        statusModal.classList.remove('hidden');
                    }
                }
            }
        }

        addStatusButton.addEventListener('click', handleStatusModalToggle);
        closeModalButton.addEventListener('click', () => statusModal.classList.add('hidden'));
        statusModal.addEventListener('click', (e) => {
             if (e.target.id === 'status-modal') statusModal.classList.add('hidden');
        });
        
        // --- Context Menu Image Logic ---
        applyUrlButton.addEventListener('click', async () => {
            const url = imageUrlInput.value.trim();
            if (url) {
                // Check if the URL is a data:image URL
                if (url.startsWith('data:image/')) {
                    const parts = url.match(/^data:(image\/.+);base64,(.*)$/);
                    if (parts && parts.length === 3) {
                        const mimeType = parts[1];
                        const base64Data = parts[2];
                        const blob = base64ToBlob(base64Data, mimeType);
                        const imageId = crypto.randomUUID();

                        try {
                            await saveImageToIndexedDB(imageId, blob);
                            // Set background image using the original data URL
                            document.querySelectorAll('.highlighted').forEach(item => {
                                item.classList.remove(...colorPalette); 
                                item.style.backgroundImage = `url('${url}')`;
                                item.dataset.indexedDbImageId = imageId; // Store IndexedDB ID
                                item.dataset.objectUrl = url; // Use data URL as object URL for consistency
                            });
                            saveStateToCookie(); // Save state with IndexedDB ID
                        } catch (error) {
                            console.error('Failed to save data:image to IndexedDB:', error);
                            // Fallback to temporary display if save fails
                            document.querySelectorAll('.highlighted').forEach(item => {
                                item.classList.remove(...colorPalette); 
                                item.style.backgroundImage = `url('${url}')`;
                                delete item.dataset.indexedDbImageId;
                                if (item.dataset.objectUrl) URL.revokeObjectURL(item.dataset.objectUrl);
                                delete item.dataset.objectUrl;
                            });
                        }
                    } else {
                        console.error('Invalid data:image format.');
                    }
                } else { // It's a regular external URL
                    document.querySelectorAll('.highlighted').forEach(item => {
                        // Remove existing color classes when applying an image
                        item.classList.remove(...colorPalette); 
                        item.style.backgroundImage = `url('${url}')`;
                        // Clear IndexedDB related data if an external URL is applied
                        delete item.dataset.indexedDbImageId;
                        if (item.dataset.objectUrl) {
                            URL.revokeObjectURL(item.dataset.objectUrl);
                            delete item.dataset.objectUrl;
                        }
                    });
                    saveStateToCookie(); // Save state after image URL change
                }
            }
            contextMenu.classList.add('hidden');
            imageUrlInput.value = '';
        });

        imageFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const blob = file; // The file object is already a Blob
                const imageId = crypto.randomUUID(); // Generate a unique ID for the image

                try {
                    await saveImageToIndexedDB(imageId, blob);
                    const objectUrl = URL.createObjectURL(blob);

                    document.querySelectorAll('.highlighted').forEach(item => {
                        // Remove existing color classes when applying an image
                        item.classList.remove(...colorPalette);
                        item.style.backgroundImage = `url('${objectUrl}')`;
                        item.dataset.indexedDbImageId = imageId; // Store the ID for persistence
                        item.dataset.objectUrl = objectUrl; // Store the object URL for revoking
                    });
                    saveStateToCookie(); // Save state after local image change (now referencing IndexedDB ID)

                } catch (error) {
                    console.error('Failed to save or load image from IndexedDB:', error);
                    // Optionally, provide user feedback about the failure
                }
            }
            contextMenu.classList.add('hidden');
            e.target.value = null; // Reset file input
        });

        // --- Button & Keyboard Logic ---
        lastTurnButton.addEventListener('click', () => {
            const lastItem = shelf.querySelector('.draggable:last-child');
            if(lastItem) {
                shelf.insertBefore(lastItem, shelf.firstChild);
                saveStateToCookie(); // Save state after turn change
            }
        });

        moveButton.addEventListener('click', () => {
            const firstItem = shelf.querySelector('.draggable');
            if(firstItem) {
                shelf.appendChild(firstItem);
                saveStateToCookie(); // Save state after turn change
            }
        });

        addButton.addEventListener('click', () => createCharacter('', 10)); // createCharacter already calls saveStateToCookie()

        removeButton.addEventListener('click', async () => {
            const selectedItems = document.querySelectorAll('.highlighted');
            for (const item of selectedItems) {
                // If it has an IndexedDB image ID, check if other elements still use it
                if (item.dataset.indexedDbImageId) {
                    const currentImageId = item.dataset.indexedDbImageId;
                    const otherElementsUsingId = Array.from(document.querySelectorAll('.draggable[data-indexed-db-image-id]')).filter(
                        el => el !== item && el.dataset.indexedDbImageId === currentImageId
                    );

                    if (otherElementsUsingId.length === 0) {
                        // Only delete from IndexedDB if no other elements are using this image ID
                        try {
                            await deleteImageFromIndexedDB(currentImageId);
                            console.log(`Deleted image ${currentImageId} from IndexedDB.`);
                        } catch (e) {
                            console.error(`Error deleting image ${currentImageId} from IndexedDB:`, e);
                        }
                    } else {
                        console.log(`Image ${currentImageId} not deleted from IndexedDB, still referenced by other elements.`);
                    }
                }
                
                // Always revoke the Object URL if it exists, as it's specific to this DOM element
                if (item.dataset.objectUrl) {
                    URL.revokeObjectURL(item.dataset.objectUrl);
                    console.log(`Revoked Object URL: ${item.dataset.objectUrl}`);
                }
                item.remove();
            }
            updateActionButtonsState();
            saveStateToCookie(); // Save state after removal
        });

        copyButton.addEventListener('click', () => {
            const originals = document.querySelectorAll('.highlighted');
            if (originals.length > 0) {
                let allNames = new Set(Array.from(document.querySelectorAll('#shelf-items .font-bold.text-lg')).map(span => span.textContent.trim()));
                let lastOriginal = originals[originals.length - 1]; // Find the last selected item to insert after

                originals.forEach(original => {
                    const originalName = original.querySelector('.font-bold.text-lg').textContent.trim();
                    const hp = original.querySelector('.text-2xl.font-mono').textContent.trim();
                    const statuses = Array.from(original.querySelectorAll('.status-container span')).map(s => s.textContent);
                    const backgroundColorClass = Array.from(original.classList).find(cls => colorPalette.includes(cls));
                    
                    let newName = originalName;
                    let insertionPoint = lastOriginal;
                    
                    if (originalName !== '') {
                        const getNextName = (currentName) => {
                            const match = currentName.match(/(.+) (\d+)$/);
                            return match ? `${match[1]} ${parseInt(match[2], 10) + 1}` : `${currentName} 2`;
                        };
                        let nextName = getNextName(originalName);
                        while (allNames.has(nextName)) {
                            nextName = getNextName(nextName);
                        }
                        newName = nextName;
                        allNames.add(newName);

                        // Find the true last item in the sequence for insertion
                        const baseName = (originalName.match(/(.+) (\d+)$/) || [null, originalName])[1];
                        const allSiblings = Array.from(document.querySelectorAll('#shelf-items .draggable')).filter(el => {
                             const nameSpan = el.querySelector('.font-bold.text-lg');
                             return nameSpan && nameSpan.textContent.trim().startsWith(baseName);
                        });
                        if (allSiblings.length > 0) {
                            insertionPoint = allSiblings[allSiblings.length -1];
                        }
                    }
                    
                    const originalBgImage = original.style.backgroundImage;
                    const originalIndexedDbImageId = original.dataset.indexedDbImageId || '';

                    const options = {
                        insertionElement: insertionPoint,
                        backgroundColorClass: backgroundColorClass
                    };

                    // If it's an IndexedDB image, pass the ID reference for creation, otherwise pass the URL
                    if (originalIndexedDbImageId) {
                        options.backgroundImage = `indexeddb://${originalIndexedDbImageId}`; // Reference existing IndexedDB image
                    } else if (originalBgImage && originalBgImage.startsWith('url(')) {
                        options.backgroundImage = originalBgImage.substring(4, originalBgImage.length - 1).replace(/['"]/g, ''); // Extract URL
                    }

                    const newCharacter = createCharacter(newName, hp, statuses, options); // createCharacter already calls saveStateToCookie()
                    
                    // The createCharacter function will handle setting the dataset.indexedDbImageId and objectUrl
                    // if options.backgroundImage was 'indexeddb://ID'.
                    lastOriginal = insertionPoint.nextElementSibling; // The new insertion point is the card we just created
                });
            }
        });

        clearStatusesButton.addEventListener('click', () => {
             document.querySelectorAll('.highlighted').forEach(item => {
                 const statusContainer = item.querySelector('.status-container');
                 if(statusContainer) statusContainer.innerHTML = '';
             });
             saveStateToCookie(); // Save state after clearing statuses
        });

        // --- Clear All Data Logic ---
        clearAllDataButton.addEventListener('click', async () => { // Direct action now
            // Clear the cookie
            setCookie('initiativeTrackerState', '', -1); // Set expiration to past
            if (db) {
                db.close();
                db = null; // Clear the reference to the database object
                console.log('IndexedDB connection closed.');
            }

            // Delete the IndexedDB database
            try {
                await new Promise((resolve, reject) => {
                    const req = indexedDB.deleteDatabase(DB_NAME);
                    req.onsuccess = () => {
                        console.log('IndexedDB database deleted successfully');
                        resolve();
                    };
                    req.onblocked = () => {
                        console.log('IndexDB deletion blocked')
                    };
                    req.onerror = (event) => {
                        console.error('Error deleting IndexedDB database:', event.target.error);
                        reject(event.target.error);
                    };
                });
            } catch (e) {
                console.error("Failed to delete IndexedDB:", e);
            }

            // Perform a "soft reset" by clearing DOM and re-initializing default scene
            shelf.innerHTML = ''; // Clear existing elements from the display
            initializeApp()
        });


        let isSelecting = false;
        let startX, startY;
        shelf.addEventListener('mousedown', (e) => {
            // Do not start selection if clicking on an already highlighted character or the black bar
            if (e.target.closest('.draggable.highlighted') || e.target.classList.contains('bg-black')) return; 

            // Allow clicking on existing non-highlighted characters to select them
            if (e.target.closest('.draggable')) {
                // If it's a character, let the regular click event handle selection
                return;
            }

            e.preventDefault();
            isSelecting = true;
            startX = e.clientX; startY = e.clientY;
            Object.assign(selectionBox.style, { left: `${startX}px`, top: `${startY}px`, width: '0px', height: '0px', display: 'block' });
            if (!e.shiftKey) {
                document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                updateActionButtonsState();
            }
        });
        window.addEventListener('mousemove', (e) => {
            if (!isSelecting) return;
            e.preventDefault();
            const currentX = e.clientX, currentY = e.clientY;
            const width = Math.abs(currentX - startX), height = Math.abs(currentY - startY);
            const left = Math.min(currentX, startX), top = Math.min(currentY, startY);
            Object.assign(selectionBox.style, { width: `${width}px`, height: `${height}px`, left: `${left}px`, top: `${top}px` });
            const boxRect = selectionBox.getBoundingClientRect();
            document.querySelectorAll('.draggable').forEach(item => {
                // Do not include the turn marker in drag selection
                if (item.classList.contains('bg-black')) return;

                const itemRect = item.getBoundingClientRect();
                const isIntersecting = !(boxRect.right < itemRect.left || boxRect.left > itemRect.right || boxRect.bottom < itemRect.top || boxRect.top > itemRect.bottom);
                if (isIntersecting) item.classList.add('highlighted');
                else if(!e.shiftKey) item.classList.remove('highlighted');
            });
            updateActionButtonsState();
        });
        window.addEventListener('mouseup', () => {
            if (isSelecting) {
                isSelecting = false;
                selectionBox.style.display = 'none';
            }
        });
        
        // --- Global Event Listeners to close popups ---
        document.addEventListener('keydown', (event) => {
            // Disable keyboard shortcuts if context menu is open
            if (!contextMenu.classList.contains('hidden')) {
                // Allow default behavior for typing into inputs within the context menu
                return;
            }

            if(event.key === 'Escape') {
                if (!statusModal.classList.contains('hidden')) statusModal.classList.add('hidden');
                else {
                    document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                    updateActionButtonsState();
                }
                return;
            }

            // Prevent shortcuts if an editable field is active
            if (document.activeElement.getAttribute('contenteditable') === 'true' || 
                document.activeElement === imageUrlInput) { // Also check for image URL input
                return;
            }
            
            // Handle number keys for status modal selection
            if (!statusModal.classList.contains('hidden') && event.code.startsWith('Digit')) {
                 event.preventDefault();
                 // Digit0 maps to 9th status, Digit1 to 0th, etc.
                 const keyNumber = event.code === 'Digit0' ? 9 : parseInt(event.code.slice(-1)) - 1;
                 const symbolButtons = symbolGrid.querySelectorAll('button');
                 if (symbolButtons[keyNumber]) symbolButtons[keyNumber].click();
                 return;
            }

            switch (event.code) {
                case 'Space': event.preventDefault(); moveButton.click(); break;
                case 'Backspace': event.preventDefault(); lastTurnButton.click(); break;
                case 'KeyA': event.preventDefault(); addButton.click(); break;
                case 'KeyS': event.preventDefault(); handleStatusModalToggle(); break;
                case 'KeyC': event.preventDefault(); if (!copyButton.disabled) copyButton.click(); break;
                case 'KeyX': event.preventDefault(); if (!clearStatusesButton.disabled) clearStatusesButton.click(); break;
                case 'Delete': event.preventDefault(); if (!removeButton.disabled) removeButton.click(); break;
            }
        });
        
        window.addEventListener('click', (e) => {
            // Close context menu if click outside it and not on a draggable item (which has its own context menu handler)
            if (!contextMenu.classList.contains('hidden') && !contextMenu.contains(e.target) && !e.target.closest('.draggable')) {
                contextMenu.classList.add('hidden');
            }
        });

        function initializeDefaultScene() {
            createTurnMarker();
            createCharacter('Goblin 1', 7);
            createCharacter('Goblin 2', 7);
            createCharacter('Goblin 3', 2, ['â¤ï¸â€ðŸ©¹']);
            createCharacter('Hector the Well-Endowed', 18, ['âš¡ï¸']);
        }
        
        // --- Initial App Start ---
        async function initializeApp() {
            populateColorMenu();
            try {
                await openIndexedDB();
                if (!await loadStateFromCookie()) {
                    initializeDefaultScene();
                }
            } catch (e) {
                console.error("Failed to initialize IndexedDB or load state:", e);
                initializeDefaultScene(); // Fallback to default if IndexedDB fails
            }
        }
        
        initializeApp();

    </script>
</body>
</html>
