<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Initiatve Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap">
    <style>
        /* Apply border-box sizing to all elements for more predictable layouts */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            user-select: none; /* Prevent text selection during drag operations */
        }
        /* Style for the contenteditable fields to give user feedback */
        [contenteditable]:focus {
            outline: none;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        [contenteditable] {
            cursor: text;
            user-select: text; /* Allow text selection inside editable fields */
        }
        /* CSS to create placeholder text for the name field */
        [data-placeholder]:empty::before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.6); /* Lighter color for hint text */
            pointer-events: none; /* Allow clicks to focus the element */
        }
        /* Visual feedback for the item being dragged */
        .dragging {
            opacity: 0.5;
            border: 2px dashed #60a5fa; /* A blue dash to stand out */
        }
        /* Make items draggable and add base transition */
        .draggable {
            cursor: grab;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            background-size: cover;
            background-position: center;
        }
        .draggable:active {
            cursor: grabbing;
        }
        /* Apply hover effect ONLY to non-highlighted items */
        .draggable:not(.highlighted):hover {
            transform: translateY(-4px);
        }

        .invisible {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-in-out;
        }

        /* --- Animation for the Highlight --- */
        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.3);
            }
            100% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
        }

        /* --- New Animation for Pop-in Effect --- */
        @keyframes pop-in {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .pop-in-animation {
            animation: pop-in 0.3s ease-out forwards;
        }

        /* Style for the highlighted/selected item */
        .highlighted {
            transform: scale(1.05) translateY(-8px); /* Slightly larger and more lifted */
            animation: pulse-border 1.5s infinite; /* Apply the new animation */
        }

        /* New style for highlighting selected statuses in the modal */
        .symbol-selected {
            background-color: #dbeafe; /* A light blue background */
            border: 2px solid #60a5fa; /* A slightly darker blue border */
        }

        /* Style for the drag-to-select box */
        #selection-box {
            position: absolute;
            border: 2px solid #60a5fa;
            background-color: rgba(59, 130, 246, 0.2);
            pointer-events: none; /* So it doesn't interfere with mouse events */
            z-index: 9999;
        }

        /* Style for the custom color context menu */
        #context-menu {
            position: absolute;
            z-index: 10000;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 8px;
            width: 200px;
        }

        /* Add a text shadow for readability over any background */
        .text-readable {
            text-shadow: 0 1px 3px rgba(0,0,0,0.6);
        }

        /* Styles for the Notes Modal's rich text editor */
        #notes-content-editable:focus {
            outline: 2px solid #3b82f6; /* Blue outline on focus */
        }
        #notes-content-editable ul {
            list-style: disc;
            margin-left: 20px;
        }
        #notes-content-editable ol {
            list-style: decimal;
            margin-left: 20px;
        }

        .clickable-roll {
            color: #60a5fa; /* Tailwind's blue-400 */
            text-decoration: underline;
            cursor: pointer;
            font-weight: 500;
        }
        .clickable-roll:hover {
            color: #3b82f6; /* Tailwind's blue-500 */
        }

        /* --- Compendium & Main Wrapper Styles --- */
        #main-wrapper {
            transition: padding-right 0.3s ease-in-out, padding-bottom 0.3s ease-in-out;
        }
        body.compendium-open #main-wrapper {
            padding-right: 260px;
        }

        #compendium-container {
            position: fixed;
            top: 0;
            right: -260px; /* Start off-screen */
            bottom: 0;
            width: 300px;
            z-index: 40; /* Below modals */
            transition: right 0.3s ease-in-out;
            display: flex;
            align-items: center;
        }
        body.compendium-open #compendium-container {
            right: 0;
        }
        #compendium-handle {
            width: 40px;
            height: 160px;
            background-color: #374151; /* gray-700 */
            border-top-left-radius: 1rem;
            border-bottom-left-radius: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #compendium-handle span {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #compendium-shelf {
            width: 260px;
            height: 100%;
            background-color: #e5e7eb; /* gray-200 */
            border-left: 1px solid #d1d5db; /* gray-300 */
            position: relative;
            display: flex;
            flex-direction: column;
        }

        #compendium-shelf-inner-wrapper {
            flex-grow: 1;
            position: relative;
            overflow-y: auto;
        }

        #compendium-shelf-inner {
            position: relative;
            width: 100%;
        }

        #compendium-shelf .character-card {
            position: absolute;
            left: 50%;
            transition: top 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        /* --- NEW: Log Section Styles --- */
        body.log-open #main-wrapper {
            padding-bottom: 200px; /* Height of the log shelf */
        }
        body.compendium-open #log-container {
            right: 260px; /* Width of the compendium shelf */
        }
        #log-container {
            position: fixed;
            left: 0;
            right: 0;
            bottom: -200px; /* Start hidden (height of log-shelf) */
            height: 240px; /* height of log-shelf + log-handle */
            z-index: 30; /* Below compendium */
            transition: bottom 0.3s ease-in-out, right 0.3s ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        body.log-open #log-container {
            bottom: 0;
        }
        #log-handle {
            width: 160px;
            height: 40px;
            background-color: #374151; /* gray-700 */
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 -4px 6px -1px rgba(0,0,0,0.1);
        }
        #log-handle span {
            color: white;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #log-shelf {
            width: 100%;
            height: 200px;
            background-color: #1f2937; /* gray-800 */
            border-top: 1px solid #4b5563; /* gray-600 */
            display: flex;
            flex-direction: column;
        }
        #log-display {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            color: white;
            font-family: monospace, monospace;
            font-size: 0.875rem; /* text-sm */
            scroll-behavior: smooth;
        }
        #log-display::-webkit-scrollbar { width: 8px; }
        #log-display::-webkit-scrollbar-track { background: #1f2937; /* gray-800 */ }
        #log-display::-webkit-scrollbar-thumb { background: #4b5563; /* gray-600 */ border-radius: 4px; }
        #log-input-wrapper {
            border-top: 1px solid #4b5563; /* gray-600 */
        }
        #log-input {
            width: 100%;
            background-color: #374151; /* gray-700 */
            color: white;
            font-family: monospace, monospace;
            padding: 0.75rem 1rem;
            outline: none;
            border: none; /* Remove border from input itself */
        }
        #log-input:focus {
             box-shadow: inset 0 0 0 2px #3b82f6; /* blue-500 ring */
        }

        /* --- Animation for the dice result text --- */
        @keyframes reveal-result-text {
            from {
                transform: scale(0.5);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .result-reveal-animation {
            animation: reveal-result-text 0.3s ease-out forwards;
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- This div is for the drag-to-select feature -->
    <div id="selection-box" style="display: none;"></div>

    <!-- Custom context menu for changing colors and images -->
    <div id="context-menu" class="invisible">
        <div class="space-y-2">
            <div>
                <label class="block text-sm font-medium text-gray-700">Image URL</label>
                <div class="mt-1 flex rounded-md shadow-sm">
                    <input type="text" id="image-url-input" class="focus:ring-indigo-500 focus:border-indigo-500 flex-1 block w-full rounded-none rounded-l-md sm:text-sm border-gray-300 p-1">
                    <button id="apply-url-btn" class="inline-flex items-center px-3 rounded-r-md border border-l-0 border-gray-300 bg-gray-50 text-gray-500 text-sm">Apply</button>
                </div>
            </div>
            <div>
                <label for="image-file-input" class="block text-sm font-medium text-gray-700">Or Upload File</label>
                <input type="file" id="image-file-input" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100"/>
            </div>
            <div class="border-t border-gray-200 pt-2">
                 <p class="text-sm font-medium text-gray-700 mb-1">Color</p>
                 <div id="color-grid" class="grid grid-cols-6 gap-2">
                    <!-- Color swatches will be populated here by JavaScript -->
                </div>
            </div>
        </div>
    </div>


    <!-- Main container for the scene -->
    <div id="main-wrapper">
        <div class="w-full max-w-6xl mx-auto px-4 py-8">

            <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Vick's Initiative Tracker</h1>

            <!-- Container for the elements, now a wrapping flex container -->
            <div id="shelf-items" class="flex flex-wrap justify-center items-start gap-4 min-h-80 p-4 bg-white rounded-lg shadow-inner">

                <!-- The Black Bar / Turn Marker is loaded dynamically -->

                <!-- Elements will be populated by JavaScript -->
            </div>

            <!-- Button Container -->
            <div id="main-button-container" class="mt-8 text-center space-y-4">
                <div class="space-x-4">
                    <button id="move-item-btn" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                        Next Turn (SPACE)
                    </button>
                     <button id="last-turn-btn" class="bg-amber-500 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-amber-600 focus:outline-none focus:ring-4 focus:ring-amber-300 transition-all duration-200">
                        Last Turn (BACKSPACE)
                    </button>
                    <button id="add-item-btn" class="bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-200">
                        Add Character (A)
                    </button>
                </div>
                <!-- Second row of buttons for actions on highlighted items -->
                <div id="action-buttons" class="space-x-4">
                    <button id="remove-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                        Remove (DELETE)
                    </button>
                    <button id="copy-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                        Copy (C)
                    </button>
                    <button id="add-status-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                        Add Status (S)
                    </button>
                    <button id="clear-statuses-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                        Clear Statuses (X)
                    </button>
                    <button id="notes-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                        Notes (N)
                    </button>
                </div>
                <!-- New row for clear all data and other toggle buttons -->
                <div class="mt-4 space-x-4">
                    <button id="hide-hp-btn" class="bg-gray-600 text-white font-bold py-2 px-5 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-300 transition-all duration-200">
                        Hide HP
                    </button>
                    <button id="clear-all-data-btn" class="bg-red-800 text-white font-bold py-2 px-5 rounded-lg shadow-md hover:bg-red-900 focus:outline-none focus:ring-4 focus:ring-red-300 transition-all duration-200">
                        Clear All Data
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Compendium Shelf HTML -->
    <div id="compendium-container">
        <div id="compendium-handle">
            <span>Compendium</span>
        </div>
        <div id="compendium-shelf">
             <input type="text" id="compendium-search" placeholder="Search..." class="p-2 m-2 rounded-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500">
             <div id="compendium-shelf-inner-wrapper">
                <div id="compendium-shelf-inner"></div>
             </div>
             <div class="p-2 border-t border-gray-300 flex space-x-2"> <!-- Added flex and space-x-2 for layout -->
                <button id="dnd5e-import-btn" class="w-full bg-blue-700 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-blue-600">DND 5e</button>
                <!-- NEW: PF2e Import Button -->
                <button id="pf2e-import-btn" class="w-full bg-purple-700 text-white font-bold py-2 px-4 rounded-md hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-purple-600">PF2e</button>
                <button id="manage-compendium-data-btn" class="w-full bg-gray-500 text-white font-bold py-2 px-4 rounded-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400">Manage Data</button>
             </div>
        </div>
    </div>

    <!-- NEW: Log Section HTML -->
    <div id="log-container">
        <div id="log-handle">
            <span>Log</span>
        </div>
        <div id="log-shelf">
            <div id="log-display">
                <!-- Log entries will be populated here -->
            </div>
            <!-- NEW: Wrapper for input and button -->
            <div id="log-input-wrapper" class="flex">
                <input type="text" id="log-input" class="flex-grow" placeholder="Type here and press Enter to log...">
                <button id="d20-roll-btn" class="flex-shrink-0 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 transition-colors">d20 (R)</button>
            </div>
        </div>
    </div>

    <!-- Status Symbol Modal -->
    <div id="status-modal" class="invisible fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-800">Select a Status Effect</h2>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <div id="symbol-grid" class="grid grid-cols-5 gap-4">
                <!-- Symbols will be populated here by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Notes Modal -->
    <div id="notes-modal" class="invisible fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-2xl h-full max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 id="notes-title" class="text-xl font-bold text-gray-800">Notes for...</h2>
                <button id="close-notes-modal-btn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-red-600 focus:outline-none">Close</button>
            </div>
            <div id="notes-content-editable" contenteditable="true" class="flex-grow overflow-y-auto p-4 border border-gray-300 rounded-md bg-gray-50">
                <!-- Rich text content goes here -->
            </div>
        </div>
    </div>

    <!-- Compendium Data Modal -->
    <div id="compendium-data-modal" class="invisible fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-2xl h-full max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-xl font-bold text-gray-800">Compendium Data (Import/Export)</h2>
                <button id="close-compendium-data-modal-btn" class="bg-green-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-green-600 focus:outline-none">Done</button>
            </div>
            <textarea id="compendium-data-textarea" class="flex-grow w-full p-2 border border-gray-300 rounded-md bg-gray-50 font-mono text-sm"></textarea>
        </div>
    </div>

    <!-- D20 Dice Roll Modal -->
    <div id="dice-modal" class="invisible fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <!-- Container for both the canvas and the text overlay -->
        <div id="d20-container" class="relative w-48 h-48">
            <canvas id="d20-canvas" class="absolute inset-0 w-full h-full"></canvas>
            <div id="d20-result-overlay" class="w-full h-full flex items-center justify-center text-white text-6xl font-bold text-readable pointer-events-none">
                <!-- The result will be shown here -->
            </div>
        </div>
    </div>


    <!-- JavaScript Logic -->
    <script>
        // Get the buttons and containers
        const lastTurnButton = document.getElementById('last-turn-btn');
        const moveButton = document.getElementById('move-item-btn');
        const addButton = document.getElementById('add-item-btn');
        const removeButton = document.getElementById('remove-btn');
        const copyButton = document.getElementById('copy-btn');
        const addStatusButton = document.getElementById('add-status-btn');
        const clearStatusesButton = document.getElementById('clear-statuses-btn');
        const shelf = document.getElementById('shelf-items');
        const compendiumShelf = document.getElementById('compendium-shelf');
        const compendiumShelfInner = document.getElementById('compendium-shelf-inner');
        const compendiumSearch = document.getElementById('compendium-search');
        const statusModal = document.getElementById('status-modal');
        const closeModalButton = document.getElementById('close-modal-btn');
        const symbolGrid = document.getElementById('symbol-grid');
        const selectionBox = document.getElementById('selection-box');
        const contextMenu = document.getElementById('context-menu');
        const colorGrid = document.getElementById('color-grid');
        const imageUrlInput = document.getElementById('image-url-input');
        const applyUrlButton = document.getElementById('apply-url-btn');
        const imageFileInput = document.getElementById('image-file-input');
        const clearAllDataButton = document.getElementById('clear-all-data-btn');
        const notesButton = document.getElementById('notes-btn');
        const notesModal = document.getElementById('notes-modal');
        const closeNotesModalButton = document.getElementById('close-notes-modal-btn');
        const notesTitle = document.getElementById('notes-title');
        const notesContentEditable = document.getElementById('notes-content-editable');
        const hideHpButton = document.getElementById('hide-hp-btn');
        const compendiumContainer = document.getElementById('compendium-container');
        const compendiumHandle = document.getElementById('compendium-handle');
        const manageCompendiumDataBtn = document.getElementById('manage-compendium-data-btn');
        const compendiumDataModal = document.getElementById('compendium-data-modal');
        const closeCompendiumDataModalBtn = document.getElementById('close-compendium-data-modal-btn');
        const compendiumDataTextarea = document.getElementById('compendium-data-textarea');
        // Get references to the DND 5e and PF2e buttons
        const dnd5eImportBtn = document.getElementById('dnd5e-import-btn');
        const pf2eImportBtn = document.getElementById('pf2e-import-btn');
        // NEW: Get references to log elements
        const logHandle = document.getElementById('log-handle');
        const logDisplay = document.getElementById('log-display');
        const logInput = document.getElementById('log-input');
        const d20RollBtn = document.getElementById('d20-roll-btn');

        // --- Dice Rolling Logic ---

        // Get references to the dice modal elements
        const diceModal = document.getElementById('dice-modal');

        // --- Three.js Dice Setup ---
        let scene, camera, renderer, die;
        // NEW: Simplified variables for the dice animation
        let isRolling = false;
        let isLoading = false;
        let currentRollResult = 0;
        let rollStartTime;
        const rollDuration = 1200; // Total duration of the roll in ms
        let sourceQuaternion, targetQuaternion;
        const d20Canvas = document.getElementById('d20-canvas');
        const d20ResultOverlay = document.getElementById('d20-result-overlay');
        let d20FaceQuaternions; // Will be populated dynamically

        let logInputHistory = [];
        let logHistoryIndex = -1; // -1 represents the user's current (new) input

        function easeOutCubic(x) {
            return 1 - Math.pow(1 - x, 3);
        }

        function generateFaceQuaternions(geometry) {
            const faceQuaternions = [];
            const targetVector = new THREE.Vector3(0, 0, 1); // We want the face normal to point to the camera

            const positionAttribute = geometry.getAttribute('position');
            const vertices = [];
            for (let i = 0; i < positionAttribute.count; i++) {
                const vertex = new THREE.Vector3();
                vertex.fromBufferAttribute(positionAttribute, i);
                vertices.push(vertex);
            }
            
            // An icosahedron has 20 faces, each defined by 3 vertices.
            for (let i = 0; i < vertices.length; i += 3) {
                const v1 = vertices[i];
                const v2 = vertices[i+1];
                const v3 = vertices[i+2];

                // Calculate the normal vector for the face
                const face = new THREE.Plane().setFromCoplanarPoints(v1, v2, v3);
                const normal = face.normal;
                
                // Calculate the quaternion that rotates the face's normal to our target vector
                const quaternion = new THREE.Quaternion().setFromUnitVectors(normal, targetVector);
                faceQuaternions.push(quaternion);
            }
            return faceQuaternions;
        }

        function init3DDice() {
            // 1. Scene
            scene = new THREE.Scene();

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, d20Canvas.clientWidth / d20Canvas.clientHeight, 0.1, 1000);
            camera.position.z = 1.7; // Smaller = closer = bigger

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ canvas: d20Canvas, alpha: true }); // alpha:true makes background transparent
            renderer.setSize(d20Canvas.clientWidth, d20Canvas.clientHeight);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.9);
            pointLight.position.set(2, 3, 4);
            scene.add(pointLight);

            // 5. Create the Die (Icosahedron for a D20)
            const geometry = new THREE.IcosahedronGeometry(1, 0); // detail 0 = sharp edges
            d20FaceQuaternions = generateFaceQuaternions(geometry);
            
            // NEW: Use a more realistic material
            const material = new THREE.MeshStandardMaterial({
                color: 0x6366f1, // Corresponds to Tailwind's indigo-500
                roughness: 0.4,
                metalness: 0.2
            });
            die = new THREE.Mesh(geometry, material);
            scene.add(die);

            // NEW: Add edges for a clearer shape
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            die.add(wireframe); // The wireframe will now rotate with the die
        }

        function animate3DDice() {
            // Keep the loop running if we are either rolling or loading.
            if (!isRolling && !isLoading) return;

            requestAnimationFrame(animate3DDice);

            if (isRolling) {
                // This is the existing logic for a normal d20 roll
                const elapsedTime = Date.now() - rollStartTime;
                let progress = elapsedTime / rollDuration;
                
                if (progress >= 1) {
                    progress = 1;
                    isRolling = false; // End the roll
                    onRollComplete(); // Trigger the completion logic
                }
                
                const easedProgress = easeOutCubic(progress);
                THREE.Quaternion.slerp(sourceQuaternion, targetQuaternion, die.quaternion, easedProgress);

            } else if (isLoading) {
                // Slower, more deliberate loading spin
                die.rotation.x += 0.02;
                die.rotation.y += 0.025;
            }

            renderer.render(scene, camera);
        }

        /**
         * Simulates a D20 roll with animation.
         * @param {number} duration - How long the rolling animation should last in milliseconds.
         */
        function rollD20() {
            isLoading = false; // Fail-safe to ensure we're not in loading mode
            diceModal.classList.remove('invisible');

            if (!scene) init3DDice();

            // Always resize renderer and camera when modal becomes visible
            const width = d20Canvas.clientWidth;
            const height = d20Canvas.clientHeight;
            if (renderer && camera) {
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }

            d20ResultOverlay.textContent = '';
            d20ResultOverlay.classList.remove('result-reveal-animation');

            // --- Set up the animation ---
            
            // 1. Pick a result, store it globally, and get the target rotation
            currentRollResult = Math.floor(Math.random() * 20) + 1;
            targetQuaternion = d20FaceQuaternions[currentRollResult - 1];

            // 2. Create a random starting rotation
            sourceQuaternion = new THREE.Quaternion();
            const randomAxis = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
            // Use the improved angle for 4-7 rotations
            const randomAngle = (Math.random() * 3 * 2 * Math.PI) + (4 * 2 * Math.PI);
            sourceQuaternion.setFromAxisAngle(randomAxis, randomAngle);

            // 3. Kick off the animation loop. It will handle the rest.
            die.quaternion.copy(sourceQuaternion);
            isRolling = true;
            rollStartTime = Date.now();
            animate3DDice();
        }

        function onRollComplete() {
            // This function is called by the animation loop when the die stops.
            d20ResultOverlay.textContent = currentRollResult;
            d20ResultOverlay.classList.add('result-reveal-animation');
            addLogEntry(`You rolled a ${currentRollResult} on a d20`);

            // After a delay to show the result, hide the modal.
            setTimeout(() => {
                diceModal.classList.add('invisible');
            }, 600);
        }

        function startLoadingAnimation() {
            // Set the state immediately.
            isRolling = false;
            isLoading = true;

            // Make the modal visible.
            diceModal.classList.remove('invisible');
            d20ResultOverlay.textContent = '';
            
            // Schedule the resizing and animation to run just before the next browser paint.
            // This is the most reliable way to ensure the canvas has correct dimensions.
            requestAnimationFrame(() => {
                // If loading was stopped while this frame was pending, do nothing.
                if (!isLoading) return;

                if (!scene) init3DDice();

                const width = d20Canvas.clientWidth;
                const height = d20Canvas.clientHeight;
                if (renderer && camera) {
                    renderer.setSize(width, height);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                }
                
                // Kick off the animation loop.
                animate3DDice();
            });
        }

        function stopLoadingAnimation() {
            // This acts as a "cancellation" flag for any pending animation frame.
            isLoading = false;
            diceModal.classList.add('invisible');
        }

        function parseAndRoll(diceString) {
            // Make a copy of the original expression for the log output.
            const originalExpression = diceString.trim();

            try {
                // First, find all dice terms (e.g., "1d20", "2d6") and replace them with their rolled result.
                // The 'g' flag ensures we replace all occurrences.
                const processedString = originalExpression.replace(/(\d+)d(\d+)/gi, (match, numDice, numSides) => {
                    let sum = 0;
                    for (let i = 0; i < parseInt(numDice, 10); i++) {
                        sum += Math.floor(Math.random() * parseInt(numSides, 10)) + 1;
                    }
                    return sum;
                });
                
                // At this point, "2d6+5" might have become "9+5".
                // Now, we need to safely evaluate this mathematical expression.
                // We sanitize it to prevent execution of malicious code.
                const sanitizedString = processedString.replace(/[^-()\d/*+.]/g, '');

                // Using new Function() is a safer alternative to eval().
                const total = new Function('return ' + sanitizedString)();

                // Return both the total and the original expression for logging.
                return { total: Math.round(total), expression: originalExpression };
                
            } catch (e) {
                console.error("Invalid dice roll expression:", e);
                return null; // Return null if the expression is invalid.
            }
        }

        // NEW: Helper function to programmatically add entries to the log
        function addLogEntry(text) {
            const logEntry = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            // Sanitize text to prevent HTML injection
            const sanitizedText = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            logEntry.innerHTML = `<span class="text-gray-400 mr-2">[${timestamp}]</span> ${sanitizedText}`;
            logDisplay.appendChild(logEntry);

            // Trim the log to the latest 100 entries
            while (logDisplay.children.length > 100) {
                logDisplay.removeChild(logDisplay.firstChild);
            }

            logDisplay.scrollTop = logDisplay.scrollHeight;
            saveState(); // Save state every time an entry is added
        }


        // --- Data ---
        const colorPalette = [
            'bg-red-500', 'bg-orange-500', 'bg-amber-500', 'bg-yellow-500', 'bg-lime-500', 'bg-green-500',
            'bg-emerald-500', 'bg-teal-500', 'bg-cyan-500', 'bg-sky-500', 'bg-blue-500', 'bg-indigo-500',
            'bg-violet-500', 'bg-purple-500', 'bg-fuchsia-500', 'bg-pink-500', 'bg-rose-500', 'bg-slate-500'
        ];
        let colorIndex = 0; // To cycle through colors for new characters
        let isHpHidden = false; // To track HP visibility state

        const statusSymbols = ['â˜ ï¸', 'ðŸ”¥', 'â„ï¸', 'âš¡ï¸', 'ðŸ›¡ï¸', 'âš”ï¸', 'â¤ï¸â€ðŸ©¹', 'ðŸ˜µ', 'ðŸ¤¢', 'â“', 'ðŸ’ª', 'ðŸŽ¯'];

        // --- IndexedDB Setup ---
        let db;
        const DB_NAME = 'initiativeTrackerDB';
        // Increased DB_VERSION to trigger onupgradeneeded for robust migration
        const DB_VERSION = 4;
        const IMAGE_STORE_NAME = 'images';
        const CHARACTER_STORE_NAME = 'characters'; // New store name

        function openIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    console.log(`IndexedDB upgrade needed from version ${event.oldVersion} to ${event.newVersion}`);

                    // Create or get 'images' store
                    let imageStore;
                    if (!db.objectStoreNames.contains(IMAGE_STORE_NAME)) {
                        imageStore = db.createObjectStore(IMAGE_STORE_NAME, { keyPath: 'id' });
                        console.log(`Created new '${IMAGE_STORE_NAME}' object store.`);
                    } else {
                        imageStore = request.transaction.objectStore(IMAGE_STORE_NAME);
                        console.log(`'${IMAGE_STORE_NAME}' object store already exists.`);
                    }

                    // Create or get 'characters' store
                    let characterStore;
                    if (!db.objectStoreNames.contains(CHARACTER_STORE_NAME)) {
                        characterStore = db.createObjectStore(CHARACTER_STORE_NAME, { keyPath: 'id' });
                        console.log(`Created new '${CHARACTER_STORE_NAME}' object store.`);
                    } else {
                        characterStore = request.transaction.objectStore(CHARACTER_STORE_NAME);
                        console.log(`'${CHARACTER_STORE_NAME}' object store already exists.`);
                    }

                    // Migration logic for old character data from localStorage to IndexedDB
                    // This will run if upgrading from a version where characters were exclusively in localStorage.
                    // Version 3 already moved characters to IndexedDB, but deleting existing stores on upgrade was a risk.
                    // This ensures data from pre-v3 states or fragmented v3 states is migrated.
                    if (event.oldVersion < 3) {
                        console.log("Attempting to migrate character data from localStorage to IndexedDB...");
                        // Access the transaction associated with the upgradeneeded event
                        const transaction = event.target.transaction;
                        const charStore = transaction.objectStore(CHARACTER_STORE_NAME);

                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            // Only process items that look like old character data saved individually
                            if (key && key.startsWith('char-')) {
                                try {
                                    const itemData = JSON.parse(localStorage.getItem(key));
                                    // Ensure it's character data and not just an order array
                                    if (itemData && typeof itemData === 'object' && itemData.type === 'character') {
                                        // Attempt to add, if ID already exists (e.g., from a partial v3 load), it will error, but not halt transaction
                                        charStore.put({ id: key, ...itemData }); // Use put to handle potential existing entries
                                        console.log(`Migrated character ${key} from localStorage to IndexedDB.`);
                                    }
                                } catch (e) {
                                    console.warn(`Could not parse or migrate localStorage item ${key}:`, e);
                                }
                            }
                        }
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('IndexedDB opened successfully');
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        async function saveImageToIndexedDB(id, blob) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.put({ id: id, blob: blob });

                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error("Failed to put image in IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function loadImageFromIndexedDB(id) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.get(id);

                request.onsuccess = (event) => resolve(event.target.result ? event.target.result.blob : null);
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        async function deleteImageFromIndexedDB(id) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.delete(id);

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        // NEW: Functions for character data in IndexedDB
        async function saveCharacterToIndexedDB(id, characterData) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CHARACTER_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CHARACTER_STORE_NAME);
                const request = store.put({ id: id, ...characterData });

                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error("Failed to put character in IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function loadCharacterFromIndexedDB(id) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CHARACTER_STORE_NAME], 'readonly');
                const store = transaction.objectStore(CHARACTER_STORE_NAME);
                const request = store.get(id);

                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => {
                    console.error("Failed to get character from IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function deleteCharacterFromIndexedDB(id) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([CHARACTER_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(CHARACTER_STORE_NAME);
                const request = store.delete(id);

                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error("Failed to delete character from IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // --- LocalStorage Persistence (now only for order) ---
        async function saveState() {
            try {
                // The localStorage parts are synchronous
                const initiativeOrder = Array.from(shelf.children).map(item => item.id);
                localStorage.setItem('initiativeOrder', JSON.stringify(initiativeOrder));
                const compendiumOrder = Array.from(compendiumShelfInner.children).map(item => item.id);
                localStorage.setItem('compendiumOrder', JSON.stringify(compendiumOrder));
                localStorage.setItem('isLogOpen', document.body.classList.contains('log-open'));
                localStorage.setItem('logContent', logDisplay.innerHTML);

                // This part now waits for all characters to be saved to IndexedDB
                const characterPromises = Array.from(document.querySelectorAll('.character-card')).map(item => {
                    const characterData = {
                        name: item.querySelector('.font-bold.text-lg')?.textContent.trim() || '',
                        hp: item.querySelector('.current-hp')?.textContent.trim() || '',
                        totalHp: item.querySelector('.total-hp')?.textContent.trim() || '',
                        statuses: Array.from(item.querySelectorAll('.status-container span')).map(s => s.textContent),
                        bgColor: Array.from(item.classList).find(cls => colorPalette.includes(cls)) || '',
                        bgImageKey: item.dataset.bgImageKey || '',
                        notes: item.dataset.notes || ''
                    };
                    return saveCharacterToIndexedDB(item.id, characterData);
                });
                await Promise.all(characterPromises); // This is the crucial await

                const turnMarker = document.querySelector('[id^="turn-marker-"]');
                if (turnMarker) {
                    const turnMarkerData = {
                        type: 'turnMarker',
                        turn: turnMarker.querySelector('.turn-counter')?.textContent.trim() || '1'
                    };
                    localStorage.setItem(turnMarker.id, JSON.stringify(turnMarkerData));
                }
                localStorage.setItem('isHpHidden', JSON.stringify(isHpHidden));

            } catch (e) {
                console.error("Failed to save state:", e);
            }
        }

        async function loadItemsToShelf(orderKey, targetParent) {
            const orderJSON = localStorage.getItem(orderKey);
            if (!orderJSON) return;

            const order = JSON.parse(orderJSON);
            const itemPromises = order.map(async (id) => {
                // Check if it's a turn marker (still stored directly in localStorage)
                if (id.startsWith('turn-marker')) {
                    const turnMarkerJSON = localStorage.getItem(id);
                    return turnMarkerJSON ? { id, data: JSON.parse(turnMarkerJSON) } : null;
                } else { // It's a character, load from IndexedDB
                    const characterData = await loadCharacterFromIndexedDB(id);
                    if (!characterData) return null;

                    let bgImageUrl = '';
                    if (characterData.bgImageKey && characterData.bgImageKey.startsWith('indexeddb://')) {
                        const blob = await loadImageFromIndexedDB(characterData.bgImageKey).catch(e => console.error(e));
                        if(blob) bgImageUrl = URL.createObjectURL(blob);
                    } else if (characterData.bgImageKey) {
                        bgImageUrl = characterData.bgImageKey;
                    }
                    characterData.bgImageUrl = bgImageUrl;
                    return { id, data: characterData };
                }
            });

            const loadedItems = await Promise.all(itemPromises);

            loadedItems.forEach(item => {
                if (!item) return;
                const { id, data } = item;
                const options = {
                    id: id,
                    parent: targetParent,
                    backgroundColorClass: data.bgColor,
                    backgroundImage: data.bgImageUrl,
                    bgImageKey: data.bgImageKey
                };
                if (data.type === 'turnMarker') {
                    createTurnMarker(id, data.turn, skip_save=true); // Turn marker always goes to main shelf
                } else { // It's a character
                    createCharacter(data.name, data.hp, data.totalHp || data.hp, data.statuses, data.notes, options, skip_save=true);
                }
            });
        }

        async function loadState() {
            try {
                shelf.innerHTML = '';
                compendiumShelfInner.innerHTML = '';
                colorIndex = 0;

                await loadItemsToShelf('initiativeOrder', shelf);
                await loadItemsToShelf('compendiumOrder', compendiumShelfInner);

                isHpHidden = JSON.parse(localStorage.getItem('isHpHidden')) || false;
                if (isHpHidden) {
                    hideHpButton.textContent = 'Show HP';
                    hideHpButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                    hideHpButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
                }

                const savedLogContent = localStorage.getItem('logContent');
                if (savedLogContent) {
                    logDisplay.innerHTML = savedLogContent;
                    logDisplay.scrollTop = logDisplay.scrollHeight;
                }
                const isLogOpen = JSON.parse(localStorage.getItem('isLogOpen')) || false;
                if (isLogOpen) {
                    document.body.classList.add('log-open');
                }

                console.log('State loaded from IndexedDB and localStorage.');
                updateActionButtonsState();
                
                // NEW: Return granular counts by checking the DOM after loading.
                // This is the key part of the fix.
                return {
                    initiativeCount: shelf.children.length,
                    compendiumCount: compendiumShelfInner.children.length
                };

            } catch (e) {
                console.error("Failed to load or parse state:", e);
                // On failure, return zero counts to allow default scene to load.
                return { initiativeCount: 0, compendiumCount: 0 };
            }
        }


        // --- Core Functions for Item States ---

        function updateActionButtonsState() {
            const selectedItems = document.querySelectorAll('.highlighted');
            const buttonsToUpdate = [removeButton, copyButton, addStatusButton, clearStatusesButton, notesButton];

            if (selectedItems.length > 0) {
                buttonsToUpdate.forEach(button => {
                    button.disabled = false;
                    button.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                });
                removeButton.classList.add('bg-red-600', 'hover:bg-red-700', 'focus:ring-4', 'focus:ring-red-300');
                copyButton.classList.add('bg-teal-600', 'hover:bg-teal-700', 'focus:ring-4', 'focus:ring-teal-300');
                addStatusButton.classList.add('bg-purple-600', 'hover:bg-purple-700', 'focus:ring-4', 'focus:ring-purple-300');
                clearStatusesButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-4', 'focus:ring-yellow-300');
                notesButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700', 'focus:ring-4', 'focus:ring-indigo-300');
            } else {
                buttonsToUpdate.forEach(button => {
                    button.disabled = true;
                    button.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                    button.classList.remove(
                        'bg-red-600', 'hover:bg-red-700', 'focus:ring-red-300',
                        'bg-teal-600', 'hover:bg-teal-700', 'focus:ring-teal-300',
                        'bg-purple-600', 'hover:bg-purple-700', 'focus:ring-purple-300',
                        'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-300',
                        'bg-indigo-600', 'hover:bg-indigo-700', 'focus:ring-indigo-300',
                        'focus:ring-4'
                    );
                });
            }
        }

        function initializeDraggable(item) {
            item.setAttribute('draggable', true);
            item.addEventListener('dragstart', (e) => {
                if (!item.classList.contains('highlighted')) {
                    document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                    item.classList.add('highlighted');
                    if (item.parentElement.id === 'compendium-shelf-inner') {
                        refreshCompendiumLayout();
                    }
                }

                item.dataset.originalParentId = item.parentElement.id;
                item.dataset.originalNextSiblingId = item.nextSibling ? item.nextSibling.id : 'null';
                setTimeout(() => item.classList.add('dragging'), 0);
            });

            item.addEventListener('dragend', (e) => {
                item.classList.remove('dragging');
                const newParent = item.parentElement;
                const originalParentId = item.dataset.originalParentId;

                if (newParent.id === 'shelf-items' && originalParentId === 'compendium-shelf-inner') {
                    item.style.position = '';
                    item.style.top = '';
                    item.style.left = '';
                    item.style.transform = '';
                    item.style.zIndex = '';
                }

                if (newParent && originalParentId && newParent.id !== originalParentId && !item.id.startsWith('turn-marker')) {

                    // When dragging a character from compendium to shelf, create a new copy
                    // Instead of moving the existing element, which belongs to compendium state
                    const originalItemData = {
                        name: item.querySelector('.font-bold.text-lg').textContent.trim(),
                        hp: item.querySelector('.current-hp').textContent.trim(),
                        totalHp: item.querySelector('.total-hp').textContent.trim(),
                        statuses: Array.from(item.querySelectorAll('.status-container span')).map(s => s.textContent),
                        notes: item.dataset.notes || '',
                        backgroundColorClass: Array.from(item.classList).find(cls => colorPalette.includes(cls)) || '',
                        backgroundImage: item.style.backgroundImage.slice(5, -2).replace(/["']/g, ""),
                        bgImageKey: item.dataset.bgImageKey || '',
                        // Do NOT pass original ID, it needs a new ID for the main shelf instance
                        // id: item.id
                    };
                    
                    // Create a new character on the target shelf
                    // The 'item' that was dragged is automatically re-inserted by the browser,
                    // we remove it to keep the compendium tidy and insert the new copy.
                    // This creates a "copy on drag" behavior.
                    if (originalParentId != newParent.id) {
                        // The dragged item is already where it should be after drop, remove the original
                        // and then recreate the original. This effectively "copies" the item.
                        
                        const tempId = item.id; // Store original ID before it changes
                        const tempOriginalParent = document.getElementById(originalParentId);
                        const tempOriginalNextSibling = (item.dataset.originalNextSiblingId && item.dataset.originalNextSiblingId !== 'null') ? document.getElementById(item.dataset.originalNextSiblingId) : null;
                        
                        // The item 'item' is now on the shelf. Give it a new ID.
                        item.id = `char-${crypto.randomUUID()}`;
                        
                        // Recreate the original item at its original position
                        createCharacter(
                            originalItemData.name,
                            originalItemData.hp,
                            originalItemData.totalHp,
                            originalItemData.statuses,
                            originalItemData.notes,
                            {
                                id: tempId, // Use the original ID for the compendium copy
                                backgroundColorClass: originalItemData.backgroundColorClass,
                                backgroundImage: originalItemData.backgroundImage,
                                bgImageKey: originalItemData.bgImageKey,
                                parent: tempOriginalParent,
                                insertBeforeSibling: tempOriginalNextSibling
                            }
                        );
                    }
                }

                delete item.dataset.originalParentId;
                delete item.dataset.originalNextSiblingId;

                refreshCompendiumLayout();
                saveState();
            });
        }

        function initializeSelectable(item) {
             if (!item.classList.contains('character-card')) return;
            item.addEventListener('click', (event) => {
                if (event.target.getAttribute('contenteditable') === 'true' || event.target.closest('.notes-indicator')) return;

                const inCompendium = item.parentElement.id === 'compendium-shelf-inner';

                if (event.shiftKey && !inCompendium) { // Allow shift-select only on main shelf
                    item.classList.toggle('highlighted');
                } else {
                    const isAlreadySelected = item.classList.contains('highlighted');
                    const selectedCount = document.querySelectorAll('.highlighted').length;

                    if (!inCompendium && isAlreadySelected && selectedCount > 1) {
                         return;
                    }

                    document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                    if (!isAlreadySelected || inCompendium || selectedCount > 1) {
                        item.classList.add('highlighted');
                    }
                }

                if (inCompendium) {
                    refreshCompendiumLayout();
                }
                updateActionButtonsState();
            });
        }

        function initializeHpField(hpSpan) {
            const parentCard = hpSpan.closest('.character-card');
            hpSpan.addEventListener('focus', () => hpSpan.dataset.originalHp = hpSpan.textContent.trim());

            const resolveHp = () => {
                const expression = hpSpan.textContent.trim();
                let newHp;
                try {
                    newHp = new Function('return (' + expression.replace(/[^-()\d/*+.]/g, '') + ')')();
                } catch (e) { newHp = parseInt(expression, 10) || 0; }
                hpSpan.textContent = Math.round(newHp);
                updateCharacterHpDisplay(parentCard);
                saveState();
            };

            hpSpan.addEventListener('blur', resolveHp);
            hpSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); resolveHp(); hpSpan.blur(); }
                else if (e.key === 'Escape') {
                    hpSpan.textContent = hpSpan.dataset.originalHp;
                    updateCharacterHpDisplay(parentCard);
                    hpSpan.blur();
                }
            });

            const nameSpan = hpSpan.closest('.draggable').querySelector('.font-bold.text-lg');
            if (nameSpan) {
                nameSpan.addEventListener('blur', saveState);
                nameSpan.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); nameSpan.blur(); }});
            }
        }

        function initializeContextMenu(item) {
            item.addEventListener('contextmenu', e => {
                e.preventDefault();
                if (!item.classList.contains('character-card')) return;

                if (!item.classList.contains('highlighted')) {
                    document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
                    item.classList.add('highlighted');
                    updateActionButtonsState();
                }

                if (item.parentElement.id === 'compendium-shelf-inner') {
                    refreshCompendiumLayout();
                }

                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.classList.remove('invisible');
            });
        }

        shelf.addEventListener('dragover', e => {
            e.preventDefault();
            const draggingItem = document.querySelector('.dragging');
            if (!draggingItem) return;
            draggingItem.style.position = '';
            const afterElement = getDragAfterElement(shelf, e.clientX, e.clientY);
            if (afterElement == null) {
                shelf.appendChild(draggingItem);
            } else {
                shelf.insertBefore(draggingItem, afterElement);
            }
        });

        compendiumShelf.addEventListener('dragover', e => {
            e.preventDefault();
            const draggingItem = document.querySelector('.dragging');
            if (draggingItem) {
                if (draggingItem.parentElement.id !== 'compendium-shelf-inner') {
                     draggingItem.style.position = 'absolute';
                }
                const afterElement = getDragAfterElement(compendiumShelfInner, e.clientX, e.clientY);
                if (afterElement) {
                     compendiumShelfInner.insertBefore(draggingItem, afterElement);
                } else {
                     compendiumShelfInner.appendChild(draggingItem);
                }
                refreshCompendiumLayout();
            }
        });

        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const isVertical = container.id === 'compendium-shelf-inner';

                const offset = isVertical ? y - box.top - box.height / 2 : x - box.left - box.width / 2;

                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- HP Display Logic ---
        function updateCharacterHpDisplay(characterElement) {
            const standardView = characterElement.querySelector('.hp-standard-view');
            const damageView = characterElement.querySelector('.hp-damage-view');
            const damageText = characterElement.querySelector('.damage-text');
            const hpHeader = characterElement.querySelector('.hp-header');

            if (!standardView || !damageView || !damageText || !hpHeader) return;

            if (isHpHidden) {
                standardView.classList.add('invisible');
                hpHeader.classList.add('invisible');

                const currentHp = parseInt(characterElement.querySelector('.current-hp').textContent, 10) || 0;
                const totalHp = parseInt(characterElement.querySelector('.total-hp').textContent, 10) || 0;
                const damage = totalHp - currentHp;

                if (damage > 0) {
                    damageText.textContent = `${damage} damage`;
                    damageView.classList.remove('invisible');
                } else {
                    damageText.textContent = '';
                    damageView.classList.add('invisible'); // Hide if no damage
                }
            } else {
                standardView.classList.remove('invisible');
                damageView.classList.add('invisible');
                hpHeader.classList.remove('invisible');
            }
        }

        function updateAllCharacterHpDisplay() {
            document.querySelectorAll('.character-card').forEach(updateCharacterHpDisplay);
        }

        // --- Compendium Layout Logic (FIXED) ---
        function refreshCompendiumLayout() {
            const searchTerm = compendiumSearch.value.toLowerCase();
            const allItems = Array.from(compendiumShelfInner.children);
            let visibleItems = [];

            // Filter visibility based on search
            allItems.forEach(item => {
                const name = item.querySelector('.font-bold.text-lg').textContent.toLowerCase();
                const isVisible = name.includes(searchTerm);
                item.style.display = isVisible ? 'block' : 'none';
                if (isVisible) {
                    visibleItems.push(item);
                }
            });

            const highlightedItem = compendiumShelfInner.querySelector('.highlighted');
            if (highlightedItem && highlightedItem.style.display === 'none') {
                highlightedItem.classList.remove('highlighted');
            }
            updateCompendiumStack(visibleItems);
        }

        function updateCompendiumStack(visibleItems) {
            if (visibleItems.length === 0) {
                compendiumShelfInner.style.height = '0px';
                return;
            };

            let highlightedItem = compendiumShelfInner.querySelector('.highlighted');
            if (!highlightedItem) {
                highlightedItem = visibleItems[0];
                highlightedItem.classList.add('highlighted');
            }

            const cardHeight = 224;
            const overlap = cardHeight * 0.85;
            const step = cardHeight - overlap;

            const totalHeight = (visibleItems.length - 1) * step + cardHeight + 40;
            compendiumShelfInner.style.height = `${totalHeight}px`;

            const highlightedIndex = visibleItems.indexOf(highlightedItem);
            const topAnchor = 16 + (highlightedIndex * step);

            highlightedItem.style.top = `${topAnchor}px`;
            highlightedItem.style.zIndex = visibleItems.length;
            highlightedItem.style.transform = 'translateX(-50%) scale(1.05)';

            for (let i = 0; i < visibleItems.length; i++) {
                const item = visibleItems[i];
                if (item === highlightedItem) continue;
                const distance = i - highlightedIndex;
                item.style.top = `${topAnchor + (distance * step)}px`;
                item.style.zIndex = visibleItems.length - 1 - Math.abs(distance);
                item.style.transform = 'translateX(-50%) scale(1)';
            }
        }


        function cycleCompendiumHighlight(direction) {
            const items = Array.from(compendiumShelfInner.children).filter(item => item.style.display !== 'none');
            if (items.length < 2) return;

            let currentHighlighted = compendiumShelfInner.querySelector('.highlighted');
            if (!currentHighlighted) {
                items[0].classList.add('highlighted');
                refreshCompendiumLayout();
                items[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
                return;
            }

            const currentIndex = items.indexOf(currentHighlighted);
            currentHighlighted.classList.remove('highlighted');

            let nextIndex;
            if (direction === 'down') {
                nextIndex = (currentIndex + 1) % items.length;
            } else { // 'up'
                nextIndex = (currentIndex - 1 + items.length) % items.length;
            }

            const newItem = items[nextIndex];
            newItem.classList.add('highlighted');
            updateActionButtonsState();
            refreshCompendiumLayout();
            newItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }


        function createCharacter(name, hp, totalHp, statuses = [], notes = '', options = {}, skip_save = false) {
            const {
                id = null, insertionElement = null, backgroundColorClass = null,
                backgroundImage = '', bgImageKey = '', parent = shelf,
                insertBeforeSibling = null
            } = options;

            const newItem = document.createElement('div');
            newItem.id = id || `char-${crypto.randomUUID()}`;
            newItem.classList.add('character-card', 'draggable');

            const newColor = backgroundColorClass || colorPalette[colorIndex++ % colorPalette.length];
            newItem.classList.add(...newColor.split(' '));
            newItem.classList.add('rounded-md', 'w-32', 'min-h-56', 'shadow-lg', 'flex', 'flex-col', 'justify-between', 'p-2', 'text-white');

            newItem.dataset.notes = notes;
            newItem.dataset.bgImageKey = bgImageKey;

            if (backgroundImage) newItem.style.backgroundImage = `url('${backgroundImage}')`;

            const nameContent = name || '';
            const namePlaceholder = name ? '' : 'data-placeholder="Name"';

            newItem.innerHTML = `
                <div class="flex flex-col items-center flex-shrink-0">
                    <span contenteditable="true" class="font-bold text-lg p-1 text-center text-readable" ${namePlaceholder}>${nameContent}</span>
                    <div class="flex flex-col items-center mt-2">
                        <span class="hp-header text-xs font-semibold text-white/80 select-none text-readable">HP</span>
                        <div class="hp-display-container">
                            <div class="hp-standard-view flex items-baseline justify-center">
                                <span contenteditable="true" class="current-hp text-2xl font-mono p-1 text-readable">${hp}</span>
                                <span class="mx-1 text-white/80">/</span>
                                <span contenteditable="true" class="total-hp text-2xl font-mono p-1 text-readable">${totalHp}</span>
                            </div>
                            <div class="hp-damage-view hidden text-center h-9 flex items-center justify-center">
                                <span class="damage-text text-lg font-semibold p-1 text-readable text-red-300"></span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="status-container w-full flex-grow mt-2 p-1 flex flex-wrap items-center justify-center content-start gap-2"></div>
                <div class="absolute bottom-1 right-1 notes-indicator text-lg" style="display: none;">ðŸ“</div>
            `;

            const statusContainer = newItem.querySelector('.status-container');
            statuses.forEach(symbol => {
                 const statusIcon = document.createElement('span');
                 statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-default text-readable";
                 statusIcon.textContent = symbol;
                 statusContainer.appendChild(statusIcon);
            });

            updateNotesIndicator(newItem);
            initializeHpField(newItem.querySelector('.current-hp'));
            initializeHpField(newItem.querySelector('.total-hp'));
            updateCharacterHpDisplay(newItem); // Apply current HP visibility state
            initializeDraggable(newItem);
            initializeSelectable(newItem);
            initializeContextMenu(newItem);

            if (parent.id === 'compendium-shelf-inner') {
                newItem.style.position = 'absolute';
            }

            if (insertBeforeSibling) {
                parent.insertBefore(newItem, insertBeforeSibling);
            } else if (insertionElement) {
                insertionElement.after(newItem);
            } else {
                parent.appendChild(newItem);
            }

            if (!options.id) { // Only animate and save if it's a newly created item
                newItem.classList.add('pop-in-animation');
                newItem.addEventListener('animationend', () => newItem.classList.remove('pop-in-animation'), { once: true });
            }
            // Ensure compendium layout is refreshed if adding to it, even if not animating
            if (parent.id === 'compendium-shelf-inner') {
                refreshCompendiumLayout();
            }
            if (!skip_save) {
                saveState();
            }
            return newItem;
        }

        function createTurnMarker(id = null, turn = '1', skip_save = false) {
            const turnMarker = document.createElement('div');
            turnMarker.id = id || `turn-marker-${crypto.randomUUID()}`;
            turnMarker.className = 'draggable flex items-end h-56';

            turnMarker.innerHTML = `
                <div class="w-4 h-full bg-black rounded-l-lg"></div>
                <div class="bg-black text-white p-2 rounded-r-lg shadow-lg">
                    <div class="text-xs font-semibold uppercase text-white/80 select-none">Turn</div>
                    <span class="turn-counter text-2xl font-mono" contenteditable="true">${turn}</span>
                </div>
            `;

            initializeDraggable(turnMarker);

            const turnCounterSpan = turnMarker.querySelector('.turn-counter');
            turnCounterSpan.addEventListener('blur', saveState);
            turnCounterSpan.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter') { e.preventDefault(); turnCounterSpan.blur(); }
            });

            shelf.appendChild(turnMarker);
            if (!skip_save) {
                saveState();
            }            
            return turnMarker; // Return the created turn marker
        }

        // --- Modal & Menu Logic ---
        function populateSymbolModal(selectedItems) {
            symbolGrid.innerHTML = '';
            statusSymbols.forEach((symbol) => {
                const symbolButton = document.createElement('button');
                symbolButton.className = "relative text-3xl p-4 rounded-lg hover:bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500";

                const allHaveStatus = Array.from(selectedItems).every(item => Array.from(item.querySelectorAll('.status-container span')).some(s => s.textContent === symbol));
                if (allHaveStatus) symbolButton.classList.add('symbol-selected');

                symbolButton.innerHTML = `<span class="pointer-events-none">${symbol}</span><span class="absolute bottom-1 right-1 text-xs font-mono bg-gray-600 text-white rounded-sm px-1.5 py-0.5 pointer-events-none">${(statusSymbols.indexOf(symbol) + 1) % 10}</span>`;

                symbolButton.addEventListener('click', () => {
                    selectedItems.forEach(item => {
                        const statusContainer = item.querySelector('.status-container');
                        if (allHaveStatus) {
                            statusContainer.querySelectorAll('span').forEach(icon => {
                                if (icon.textContent === symbol) icon.remove();
                            });
                        } else if (!Array.from(statusContainer.querySelectorAll('span')).some(s => s.textContent === symbol)) {
                            const statusIcon = document.createElement('span');
                            statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-default text-readable";
                            statusIcon.textContent = symbol;
                            statusContainer.appendChild(statusIcon);
                        }
                    });
                    populateSymbolModal(selectedItems);
                    saveState();
                });
                symbolGrid.appendChild(symbolButton);
            });
        }

        function populateColorMenu() {
            colorGrid.innerHTML = '';
            colorPalette.forEach(color => {
                const swatch = document.createElement('button');
                swatch.className = `w-8 h-8 rounded-full ${color} border-2 border-white/50 hover:scale-110 transition-transform`;
                swatch.addEventListener('click', () => {
                    document.querySelectorAll('.highlighted').forEach(item => {
                        item.style.backgroundImage = '';
                        item.dataset.bgImageKey = '';
                        item.classList.remove(...colorPalette);
                        item.classList.add(color);
                    });
                    contextMenu.classList.add('invisible');
                    saveState();
                });
                colorGrid.appendChild(swatch);
            });
        }

        function handleStatusModalToggle() {
             if (!statusModal.classList.contains('invisible')) {
                statusModal.classList.add('invisible');
            } else if (!addStatusButton.disabled) {
                const selectedItems = document.querySelectorAll('.highlighted');
                if (selectedItems.length > 0) {
                    populateSymbolModal(selectedItems);
                    statusModal.classList.remove('invisible');
                }
            }
        }

        function updateNotesIndicator(item) {
            const indicator = item.querySelector('.notes-indicator');
            if (indicator) indicator.style.display = item.dataset.notes ? 'block' : 'none';
        }

        function makeDiceRollsClickable(htmlString) {
            // This regex finds dice notation like "1d20", "2d6+5", or "1d8 - 2".
            // It looks for a number, 'd', a number, and then an optional +/- modifier.
            const rollRegex = /\b(\d+d\d+(\s*[+-]\s*\d+)?)\b/gi;
            
            return htmlString.replace(rollRegex, (match) => {
                const cleanMatch = match.replace(/\s/g, ''); // Remove whitespace for the roll parser
                return `<span class="clickable-roll" title="Click to roll ${cleanMatch}">${match}</span>`;
            });
        }

        function openNotesModal() {
            const selectedItems = document.querySelectorAll('.highlighted');
            if (selectedItems.length === 0) return;

            const firstItem = selectedItems[0];
            const name = firstItem.querySelector('.font-bold.text-lg').textContent.trim() || 'Unnamed Character';
            notesTitle.textContent = `Notes for ${name}`;
            if (selectedItems.length > 1) notesTitle.textContent += ` (+${selectedItems.length - 1} others)`;

            // Get the raw notes HTML from the character data
            const rawNotes = firstItem.dataset.notes || '';
            
            // NEW: Process the raw notes to make dice strings clickable
            const processedNotes = makeDiceRollsClickable(rawNotes);
            
            // Set the content of the editor to the new, processed HTML
            notesContentEditable.innerHTML = processedNotes;

            notesModal.classList.remove('invisible');
        }

        function closeNotesModal() {
            const newNotes = notesContentEditable.innerHTML;
            document.querySelectorAll('.highlighted').forEach(item => {
                item.dataset.notes = newNotes;
                updateNotesIndicator(item);
            });
            notesModal.classList.add('invisible');
            saveState();
        }

        notesButton.addEventListener('click', openNotesModal);
        notesContentEditable.addEventListener('click', (e) => {
            // Check if the user clicked on a span with our special class
            if (e.target.classList.contains('clickable-roll')) {
                const diceExpression = e.target.textContent;
                const result = parseAndRoll(diceExpression);

                if (result !== null) {
                    // Log the result in a clear format
                    addLogEntry(`Rolled ${result.expression}: ${result.total}`);

                    // If the log panel is closed, open it to show the result.
                    if (!document.body.classList.contains('log-open')) {
                        logHandle.click();
                    }
                }
            }
        });
        closeNotesModalButton.addEventListener('click', closeNotesModal);
        addStatusButton.addEventListener('click', handleStatusModalToggle);
        closeModalButton.addEventListener('click', () => statusModal.classList.add('invisible'));
        statusModal.addEventListener('click', (e) => { if (e.target === statusModal) statusModal.classList.add('invisible'); });

        applyUrlButton.addEventListener('click', () => {
            const url = imageUrlInput.value.trim();
            if (url) {
                document.querySelectorAll('.highlighted').forEach(item => {
                    item.style.backgroundImage = `url('${url}')`;
                    item.dataset.bgImageKey = url;
                });
                saveState();
            }
            contextMenu.classList.add('invisible');
            imageUrlInput.value = '';
        });

        imageFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const imageId = `indexeddb://${crypto.randomUUID()}`;
                await saveImageToIndexedDB(imageId, file);
                const objectUrl = URL.createObjectURL(file);
                document.querySelectorAll('.highlighted').forEach(item => {
                    item.style.backgroundImage = `url('${objectUrl}')`;
                    item.dataset.bgImageKey = imageId;
                });
                saveState();
            }
            contextMenu.classList.add('invisible');
            e.target.value = null;
        });

        manageCompendiumDataBtn.addEventListener('click', async () => {
            const compendiumItems = Array.from(compendiumShelfInner.children);
            const exportDataPromises = compendiumItems.map(async item => {
                let imageKey = item.dataset.bgImageKey || '';
                // Only include the image URL if it's not an IndexedDB key
                let exportedImage = '';
                if (imageKey && !imageKey.startsWith('indexeddb://')) {
                    exportedImage = imageKey;
                }
                 // If it's an IndexedDB key, try to convert it to base64 for export
                if (imageKey.startsWith('indexeddb://')) {
                    const blob = await loadImageFromIndexedDB(imageKey);
                    if (blob) {
                        exportedImage = await new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result);
                            reader.readAsDataURL(blob);
                        });
                    }
                }


                return {
                    name: item.querySelector('.font-bold.text-lg').textContent.trim(),
                    hp: item.querySelector('.current-hp').textContent.trim(),
                    totalHp: item.querySelector('.total-hp').textContent.trim(),
                    statuses: Array.from(item.querySelectorAll('.status-container span')).map(s => s.textContent),
                    bgColor: Array.from(item.classList).find(cls => colorPalette.includes(cls)) || '',
                    bgImageKey: exportedImage, // Use the exported image or empty string
                    notes: item.dataset.notes || ''
                };
            });

            const exportData = await Promise.all(exportDataPromises);
            const jsonString = JSON.stringify(exportData, null, 2);
            compendiumDataTextarea.value = jsonString;
            compendiumDataTextarea.dataset.originalValue = jsonString;
            compendiumDataModal.classList.remove('invisible');
        });

        closeCompendiumDataModalBtn.addEventListener('click', async () => {
            const currentJson = compendiumDataTextarea.value;
            const originalJson = compendiumDataTextarea.dataset.originalValue;

            if (currentJson !== originalJson) {
                try {
                    const importData = JSON.parse(currentJson);
                    if (!Array.isArray(importData)) throw new Error("Data must be an array.");

                    // Clear existing compendium and associated images
                    const currentCompendiumItems = Array.from(compendiumShelfInner.children);
                    for (const item of currentCompendiumItems) {
                        if (item.dataset.bgImageKey && item.dataset.bgImageKey.startsWith('indexeddb://')) {
                            await deleteImageFromIndexedDB(item.dataset.bgImageKey);
                        }
                        await deleteCharacterFromIndexedDB(item.id);
                    }
                    compendiumShelfInner.innerHTML = '';


                    // Import new data
                    for (const charData of importData) {
                        let actualBgImageKey = charData.bgImageKey || '';
                        let displayBgImage = actualBgImageKey;

                        if (actualBgImageKey.startsWith('data:image/')) {
                            // If it's a base64 string, convert to Blob and save to IndexedDB
                            try {
                                const blob = await (await fetch(actualBgImageKey)).blob();
                                const newImageId = `indexeddb://${crypto.randomUUID()}`;
                                await saveImageToIndexedDB(newImageId, blob);
                                actualBgImageKey = newImageId; // Update the key to reference IndexedDB
                                displayBgImage = URL.createObjectURL(blob); // For display
                            } catch (e) {
                                console.error("Error converting base64 image to Blob for IndexedDB:", e);
                                actualBgImageKey = ''; // Clear if conversion fails
                                displayBgImage = '';
                            }
                        }

                        createCharacter(
                            charData.name,
                            charData.hp,
                            charData.totalHp,
                            charData.statuses,
                            charData.notes,
                            {
                                parent: compendiumShelfInner,
                                backgroundColorClass: charData.bgColor,
                                backgroundImage: displayBgImage,
                                bgImageKey: actualBgImageKey
                            }
                        );
                    }

                    refreshCompendiumLayout();
                    saveState();

                } catch (e) {
                    console.error("Failed to import compendium data:", e);
                    alert("Failed to import compendium data. Please check JSON format.");
                }
            }

            compendiumDataModal.classList.add('invisible');
        });

        /**
         * Fetches and imports character data from a specified JSON file.
         * @param {string} filename - The name of the JSON file to fetch.
         */
        async function fetchAndImportCharacterData(filename) {
            startLoadingAnimation();

            try {
                const response = await fetch(filename);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const jsonData = await response.json();
                const count = await importCharacterData(jsonData, filename);
                
                if (count > 0) {
                    addLogEntry(`Loaded ${count} items to compendium from ${filename}.`);
                }
            } catch (error) {
                console.error(`Error fetching or parsing ${filename}:`, error);
                alert(`Failed to load data from '${filename}'.`);
            } finally {
                // Always stop the animation, even on error.
                stopLoadingAnimation();
            }
        }

        /**
         * Imports character data into the compendium from a parsed JSON array.
         * @param {Array<Object>} data - An array of character objects to import.
         * @param {string} [source='unknown'] - Optional source of the data for logging/alerts.
         */
        function importCharacterData(data, source = 'unknown') {
            if (!Array.isArray(data)) {
                console.error(`Data from ${source} is not an array. Expected an array of character objects.`);
                alert(`Data format from '${source}' is incorrect. Expected an array of character objects.`);
                return;
            }

            data.forEach(charData => {
                const name = charData.name || 'Unnamed Character';
                const hp = charData.hp || '10';
                const totalHp = charData.totalHp || charData.hp || '10';
                const statuses = Array.isArray(charData.statuses) ? charData.statuses : [];
                const notes = charData.notes || '';
                const bgColor = charData.bgColor || '';
                const bgImageKey = charData.bgImageKey || '';

                createCharacter(
                    name, hp, totalHp, statuses, notes,
                    {
                        parent: compendiumShelfInner,
                        backgroundColorClass: bgColor,
                        backgroundImage: bgImageKey,
                        bgImageKey: bgImageKey
                    },
                    skip_save = true // Don't save immediately, we'll do it after all items are added
                );
            });

            refreshCompendiumLayout();
            saveState();
            console.log(`Character data imported successfully from ${source}!`);
        }

        // Event listener for the DND 5e button
        dnd5eImportBtn.addEventListener('click', () => fetchAndImportCharacterData('dnd_5e.json'));

        // Event listener for the PF2e button
        pf2eImportBtn.addEventListener('click', () => fetchAndImportCharacterData('pf2e_core.json'));


        // --- Button & Keyboard Logic ---
        lastTurnButton.addEventListener('click', () => {
            const lastItem = shelf.querySelector('.draggable:last-child');
            if(lastItem) {
                shelf.insertBefore(lastItem, shelf.firstChild);
                if (lastItem.id.startsWith('turn-marker')) {
                    const counter = lastItem.querySelector('.turn-counter');
                    let currentTurn = parseInt(counter.textContent, 10);
                    if (!isNaN(currentTurn) && currentTurn > 1) counter.textContent = currentTurn - 1;
                }
                saveState();
            }
        });

        moveButton.addEventListener('click', () => {
            const firstItem = shelf.querySelector('.draggable');
            if(firstItem) {
                shelf.appendChild(firstItem);
                if (firstItem.id.startsWith('turn-marker')) {
                    const counter = firstItem.querySelector('.turn-counter');
                    let currentTurn = parseInt(counter.textContent, 10);
                    counter.textContent = isNaN(currentTurn) ? 1 : currentTurn + 1;
                }
                saveState();
            }
        });

        // Function to handle adding characters, either new or from compendium
        function handleAddCharacter() {
            const selectedCompendiumCharacters = Array.from(compendiumShelfInner.querySelectorAll('.highlighted.character-card'));

            if (selectedCompendiumCharacters.length > 0) {
                // Create copies of selected compendium characters on the main shelf
                selectedCompendiumCharacters.forEach(original => {
                    const originalName = original.querySelector('.font-bold.text-lg').textContent.trim();
                    const hp = original.querySelector('.current-hp').textContent.trim();
                    const totalHp = original.querySelector('.total-hp').textContent.trim();
                    const statuses = Array.from(original.querySelectorAll('.status-container span')).map(s => s.textContent);
                    const notes = original.dataset.notes || '';
                    const bgImageKey = original.dataset.bgImageKey || '';
                    const bgStyle = original.style.backgroundImage;

                    createCharacter(
                        originalName, hp, totalHp, statuses, notes,
                        {
                            parent: shelf, // Add to main shelf
                            backgroundColorClass: Array.from(original.classList).find(cls => colorPalette.includes(cls)) || '',
                            backgroundImage: bgStyle ? bgStyle.substring(5, bgStyle.length - 2).replace(/["']/g, '') : '',
                            bgImageKey: bgImageKey
                        }
                    );
                });
            } else {
                // No compendium characters selected, create a blank one
                createCharacter('', 10, 10, [], '', {});
            }
        }

        addButton.addEventListener('click', handleAddCharacter);


        removeButton.addEventListener('click', async () => {
            const highlightedItems = document.querySelectorAll('.highlighted');
            for (const item of highlightedItems) {
                const wasInCompendium = item.parentElement.id === 'compendium-shelf-inner';

                // Delete from IndexedDB if it's a character
                if (item.classList.contains('character-card')) {
                    await deleteCharacterFromIndexedDB(item.id);
                    // Also delete associated image if it was stored in IndexedDB
                    if (item.dataset.bgImageKey && item.dataset.bgImageKey.startsWith('indexeddb://')) {
                        await deleteImageFromIndexedDB(item.dataset.bgImageKey);
                    }
                }
                // For turn markers, only delete from localStorage
                if (item.id.startsWith('turn-marker')) {
                    localStorage.removeItem(item.id);
                }

                item.remove();
                if (wasInCompendium) {
                    refreshCompendiumLayout();
                }
            }
            updateActionButtonsState();
            saveState(); // Save state after deletion (important for order persistence)
        });


        copyButton.addEventListener('click', () => {
            const originals = document.querySelectorAll('.highlighted');
            if (originals.length === 0) return;

            originals.forEach(original => {
                const parentShelf = original.closest('#shelf-items, #compendium-shelf-inner');
                const originalName = original.querySelector('.font-bold.text-lg').textContent.trim();

                const nameMatch = originalName.match(/(.+) (\d+)$/);
                const baseName = nameMatch ? nameMatch[1] : originalName;

                const allCharactersOnShelf = Array.from(parentShelf.querySelectorAll('.character-card'));
                let highestNumber = 0;
                let insertionTarget = original;

                allCharactersOnShelf.forEach(char => {
                    const charName = char.querySelector('.font-bold.text-lg').textContent.trim();
                    if (charName.startsWith(baseName)) {
                        const charMatch = charName.match(/(\d+)$/);
                        if (charMatch) {
                            const currentNum = parseInt(charMatch[1], 10);
                            if (currentNum > highestNumber) {
                                highestNumber = currentNum;
                                if (char.parentElement === parentShelf) {
                                    insertionTarget = char;
                                }
                            }
                        } else if (highestNumber === 0) {
                            highestNumber = 1;
                            if (char.parentElement === parentShelf) {
                                insertionTarget = char;
                            }
                        }
                    }
                });

                const newNumber = highestNumber + 1;
                const newName = `${baseName} ${newNumber}`;

                const hp = original.querySelector('.current-hp').textContent.trim();
                const totalHp = original.querySelector('.total-hp').textContent.trim();
                const statuses = Array.from(original.querySelectorAll('.status-container span')).map(s => s.textContent);
                const notes = original.dataset.notes || '';
                const bgImageKey = original.dataset.bgImageKey || '';
                const bgStyle = original.style.backgroundImage;

                const options = {
                    parent: parentShelf,
                    insertionElement: insertionTarget,
                    backgroundImage: bgStyle ? bgStyle.substring(5, bgStyle.length - 2).replace(/[""]/g, '') : '',
                    bgImageKey: bgImageKey
                };
                createCharacter(newName, hp, totalHp, statuses, notes, options);
            });
        });

        hideHpButton.addEventListener('click', () => {
            isHpHidden = !isHpHidden;
            updateAllCharacterHpDisplay();
            if (isHpHidden) {
                hideHpButton.textContent = 'Show HP';
                hideHpButton.classList.remove('bg-gray-600', 'hover:bg-gray-700', 'focus:ring-gray-300');
                hideHpButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700', 'focus:ring-cyan-300');
            } else {
                hideHpButton.textContent = 'Hide HP';
                hideHpButton.classList.add('bg-gray-600', 'hover:bg-gray-700', 'focus:ring-gray-300');
                hideHpButton.classList.remove('bg-cyan-600', 'hover:bg-cyan-700', 'focus:ring-cyan-300');
            }
            saveState();
        });

        clearStatusesButton.addEventListener('click', () => {
             document.querySelectorAll('.highlighted .status-container').forEach(c => c.innerHTML = '');
             saveState();
        });

        clearAllDataButton.addEventListener('click', async () => {
            // Clear localStorage entries
            localStorage.clear();

            // Clear IndexedDB object stores
            if (db) {
                const transaction = db.transaction([IMAGE_STORE_NAME, CHARACTER_STORE_NAME], 'readwrite');
                const imageStore = transaction.objectStore(IMAGE_STORE_NAME);
                const characterStore = transaction.objectStore(CHARACTER_STORE_NAME);
                
                await new Promise((resolve, reject) => {
                    const imgClearRequest = imageStore.clear();
                    imgClearRequest.onsuccess = () => {
                        const charClearRequest = characterStore.clear();
                        charClearRequest.onsuccess = () => resolve();
                        charClearRequest.onerror = (event) => reject(event.target.error);
                    };
                    imgClearRequest.onerror = (event) => reject(event.target.error);
                }).catch(e => console.error("Failed to clear IndexedDB stores:", e));
            }
            shelf.innerHTML = '';
            compendiumShelfInner.innerHTML = '';
            logDisplay.innerHTML = '';
            await initializeApp(); // Re-initialize the app to default state
        });

        compendiumHandle.addEventListener('click', () => {
            document.body.classList.toggle('compendium-open');
        });

        compendiumSearch.addEventListener('input', refreshCompendiumLayout);

        let isMouseOverCompendium = false;
        compendiumContainer.addEventListener('mouseenter', () => { isMouseOverCompendium = true; });
        compendiumContainer.addEventListener('mouseleave', () => { isMouseOverCompendium = false; });

        compendiumShelf.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY > 0) {
                cycleCompendiumHighlight('down');
            } else {
                cycleCompendiumHighlight('up');
            }
        });

        // NEW: Log Handle listener
        logHandle.addEventListener('click', () => {
            document.body.classList.toggle('log-open');
            saveState(); // Save the new open/closed state
        });
        
        // Event listener for the log input (refactored to use helper)
        logInput.addEventListener('keydown', (e) => {
            const isHistoryNavigation = e.key === 'ArrowUp' || e.key === 'ArrowDown';

            if (isHistoryNavigation) {
                e.preventDefault();

                if (e.key === 'ArrowUp') {
                    // Move backwards in history (towards older entries)
                    if (logHistoryIndex < logInputHistory.length - 1) {
                        logHistoryIndex++;
                    }
                } else { // ArrowDown
                    // Move forwards in history (towards newer entries)
                    if (logHistoryIndex >= 0) {
                        logHistoryIndex--;
                    }
                }

                if (logHistoryIndex >= 0) {
                    // If we are in the history, show the historical command
                    // We reverse the index to show the most recent item first
                    logInput.value = logInputHistory[logInputHistory.length - 1 - logHistoryIndex];
                } else {
                    // If we are at the "present", the input is blank
                    logInput.value = '';
                }
                
                // Move the cursor to the end of the input text
                logInput.focus();
                setTimeout(() => logInput.setSelectionRange(logInput.value.length, logInput.value.length), 0);
                return; // Stop further processing for arrow keys
            }

            // If the user types any other key, reset their position in the history.
            logHistoryIndex = -1;

            if (e.key === 'Enter' && logInput.value.trim() !== '') {
                e.preventDefault();
                const inputText = logInput.value.trim();

                // --- NEW HISTORY LOGIC ---
                // Check if we are currently viewing an unchanged command from history
                const isResubmittingHistory = logHistoryIndex !== -1 && inputText === logInputHistory[logInputHistory.length - 1 - logHistoryIndex];

                if (isResubmittingHistory) {
                    // The user pressed enter on an old command without editing it.
                    // We remove it from its old position and will add it back to the end.
                    const originalIndex = logInputHistory.length - 1 - logHistoryIndex;
                    logInputHistory.splice(originalIndex, 1);
                }
                
                // Add the command to the end of the history.
                // Avoid adding consecutive duplicates if the user spams Enter on the same new command.
                if (inputText && logInputHistory[logInputHistory.length - 1] !== inputText) {
                    logInputHistory.push(inputText);
                }

                // Ensure the history doesn't exceed 20 entries.
                if (logInputHistory.length > 20) {
                    logInputHistory.shift();
                }
                // --- END NEW HISTORY LOGIC ---

                // Reset history navigation after submitting
                logHistoryIndex = -1;

                // --- This is the existing roll/log logic, it remains unchanged ---
                if (inputText.toLowerCase().startsWith('/roll ')) {
                    const diceExpression = inputText.substring(6).trim();
                    const result = parseAndRoll(diceExpression);
                    if (result !== null) {
                        addLogEntry(`You rolled a ${result.total} (${result.expression})`);
                    } else {
                        addLogEntry(`Invalid roll command: /roll ${diceExpression}`);
                    }
                } else {
                    addLogEntry(inputText);
                }
                
                logInput.value = ''; // Clear input after processing
            }
        });

        d20RollBtn.addEventListener('click', () => rollD20());

        let isSelecting = false;
        let startX, startY;
        document.body.addEventListener('mousedown', (e) => {
            if (e.target.closest('.draggable, #compendium-container, #status-modal, #notes-modal, #context-menu, #main-button-container, #compendium-data-modal, #log-container')) return;
            e.preventDefault();
            isSelecting = true;
            startX = e.clientX; startY = e.clientY;
            Object.assign(selectionBox.style, { left: `${startX}px`, top: `${startY}px`, width: '0px', height: '0px', display: 'block' });
            if (!e.shiftKey) {
                document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                updateActionButtonsState();
            }
        });
        window.addEventListener('mousemove', (e) => {
            if (!isSelecting) return;
            e.preventDefault();
            const currentX = e.clientX, currentY = e.clientY;
            const width = Math.abs(currentX - startX), height = Math.abs(currentY - startY);
            const left = Math.min(currentX, startX), top = Math.min(currentY, startY);
            Object.assign(selectionBox.style, { width: `${width}px`, height: `${height}px`, left: `${left}px`, top: `${top}px` });
            const boxRect = selectionBox.getBoundingClientRect();
            document.querySelectorAll('.draggable.character-card').forEach(item => {
                const itemRect = item.getBoundingClientRect();
                const isIntersecting = !(boxRect.right < itemRect.left || boxRect.left > itemRect.right || boxRect.bottom < itemRect.top || boxRect.top > itemRect.bottom);
                if (isIntersecting) item.classList.add('highlighted');
                else if(!e.shiftKey) item.classList.remove('highlighted');
            });
            updateActionButtonsState();
        });
        window.addEventListener('mouseup', () => {
            if (isSelecting) {
                isSelecting = false;
                selectionBox.style.display = 'none';
            }
        });

        document.addEventListener('keydown', (event) => {
            const isNotesModalOpen = !notesModal.classList.contains('invisible');
            const isStatusModalOpen = !statusModal.classList.contains('invisible');
            const isContextMenuOpen = !contextMenu.classList.contains('invisible');
            const activeElementIsEditable = document.activeElement.getAttribute('contenteditable') === 'true' || ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);

            if (event.key === 'Escape') {
                if (isNotesModalOpen) return closeNotesModal();
                if (isStatusModalOpen) return statusModal.classList.add('invisible');
                if (isContextMenuOpen) return contextMenu.classList.add('invisible');
                document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                updateActionButtonsState();
                refreshCompendiumLayout();
                return;
            }

            // Check for the status modal's shortcuts BEFORE checking for other active inputs.
            if (isStatusModalOpen) {
                if (event.code.startsWith('Digit')) {
                    event.preventDefault();
                    const keyNumber = event.code === 'Digit0' ? 9 : parseInt(event.code.slice(-1)) - 1;
                    if (symbolGrid.children[keyNumber]) symbolGrid.children[keyNumber].click();
                }
                return; // Stop processing other keys if the status modal is open
            }

            if (isNotesModalOpen && event.code === 'KeyN' && document.activeElement !== notesContentEditable) {
                event.preventDefault();
                return closeNotesModal();
            }
            if (isNotesModalOpen || isStatusModalOpen || isContextMenuOpen || activeElementIsEditable) return;

            if (isMouseOverCompendium) {
                if (event.code === 'ArrowDown') {
                    event.preventDefault();
                    cycleCompendiumHighlight('down');
                } else if (event.code === 'ArrowUp') {
                    event.preventDefault();
                    cycleCompendiumHighlight('up');
                }
            }

            switch (event.code) {
                case 'Space': event.preventDefault(); moveButton.click(); break;
                case 'Backspace': event.preventDefault(); lastTurnButton.click(); break;
                case 'KeyA': event.preventDefault(); handleAddCharacter(); break; // Use handleAddCharacter
                case 'KeyS': event.preventDefault(); if (!addStatusButton.disabled) handleStatusModalToggle(); break;
                case 'KeyC': event.preventDefault(); if (!copyButton.disabled) copyButton.click(); break;
                case 'KeyX': event.preventDefault(); if (!clearStatusesButton.disabled) clearStatusesButton.click(); break;
                case 'KeyN': event.preventDefault(); if (!notesButton.disabled) openNotesModal(); break;
                case 'Delete': event.preventDefault(); if (!removeButton.disabled) removeButton.click(); break;
                case 'KeyR':
                    event.preventDefault();
                    rollD20();
                    // If the log panel is closed, open it to show the result.
                    if (!document.body.classList.contains('log-open')) {
                        logHandle.click();
                    }
                    break;
            }
        });

        window.addEventListener('click', (e) => {
            if (!contextMenu.classList.contains('invisible') && !contextMenu.contains(e.target) && !e.target.closest('.draggable')) {
                contextMenu.classList.add('invisible');
            }
        });

        async function initializeDefaultScene() {
            // Clear the shelves, but not all of localStorage
            shelf.innerHTML = '';
            compendiumShelfInner.innerHTML = '';
            
            colorIndex = 0;
            const goblinImageUrl = 'https://www.dndbeyond.com/avatars/thumbnails/30783/955/1000/1000/638062024584880857.png';
            const goblinNotes = `<p><strong>Goblin</strong><br><em>Small Humanoid (Goblinoid), Neutral Evil</em></p><hr><p><strong>Armor Class</strong> 15 (leather armor, shield)<br><strong>Hit Points</strong> 7 (2d6)<br><strong>Speed</strong> 30 ft.</p><hr><p><strong>STR</strong> 8 (-1) | <strong>DEX</strong> 14 (+2) | <strong>CON</strong> 10 (+0) | <strong>INT</strong> 10 (+0) | <strong>WIS</strong> 8 (-1) | <strong>CHA</strong> 8 (-1)</p><hr><p><strong>Skills</strong> Stealth +6<br><strong>Senses</strong> Darkvision 60 ft., Passive Perception 9<br><strong>Languages</strong> Common, Goblin<br><strong>Challenge</strong> 1/4 (50 XP) | <strong>Proficiency Bonus</strong> +2</p><hr><p><strong><em>Nimble Escape.</em></strong> The goblin can take the Disengage or Hide action as a bonus action on each of its turns.</p><p><strong>Actions</strong><br><strong><em>Scimitar.</em></strong> <em>Melee Weapon Attack:</em> +4 to hit, reach 5 ft., one target. <em>Hit:</em> 5 (1d6 + 2) slashing damage.<br><strong><em>Shortbow.</em></strong> <em>Ranged Weapon Attack:</em> +4 to hit, range 80/320 ft., one target. <em>Hit:</em> 5 (1d6 + 2) piercing damage.</p>`;
            const hectorImageUrl = 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQg4hykDiVWaLpgPyX2boVONNK76mugungN3A&s';

            // Create all items with skip_save = true
            createTurnMarker(null, '1', true);
            const goblinOptions = { bgImageKey: goblinImageUrl, backgroundImage: goblinImageUrl };
            const hectorOptions = { bgImageKey: hectorImageUrl, backgroundImage: hectorImageUrl };
            createCharacter('Goblin 1', 7, 7, [], goblinNotes, goblinOptions, true);
            createCharacter('Goblin 2', 7, 7, [], goblinNotes, goblinOptions, true);
            createCharacter('Goblin 3', 4, 7, ['â¤ï¸â€ðŸ©¹'], goblinNotes, goblinOptions, true);
            createCharacter('Hector the Well-Endowed', 18, 18, ['âš¡ï¸'], '', hectorOptions, true);
            createCharacter('Goblin', 7, 7, [], goblinNotes, { ...goblinOptions, parent: compendiumShelfInner }, true);
            
            logDisplay.innerHTML = `<div><span class="text-gray-400 mr-2">[11:46:00]</span> Welcome to the Initiative Tracker! (hint, try typing /roll 1d20)</div>`;
            
            // Perform one final save after creating all items
            await saveState();

            // Return the specific counts
            return { initiativeCount: 5, compendiumCount: 1 };
        }

        async function initializeApp() {
            populateColorMenu();
            await openIndexedDB();

            startLoadingAnimation();
            
            try {
                const { initiativeCount, compendiumCount } = await loadState();

                if (initiativeCount === 0 && compendiumCount === 0) {
                    const defaultCounts = await initializeDefaultScene();
                    addLogEntry(`Loaded ${defaultCounts.initiativeCount + defaultCounts.compendiumCount} default items: ${defaultCounts.initiativeCount} to Initiative, ${defaultCounts.compendiumCount} to Compendium.`);
                } else {
                    addLogEntry(`Loaded ${initiativeCount} items to Initiative and ${compendiumCount} items to Compendium.`);
                }
            } catch (error) {
                console.error("An error occurred during app initialization:", error);
                addLogEntry("Error during initialization. State may be incomplete.");
            } finally {
                // This is GUARANTEED to run, even if an error occurs.
                stopLoadingAnimation();
                updateAllCharacterHpDisplay();
                refreshCompendiumLayout();
            }
        }

        initializeApp();

    </script>
</body>
</html>
