<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid of Elements</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap">
    <style>
        /* Apply border-box sizing to all elements for more predictable layouts */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            user-select: none; /* Prevent text selection during drag operations */
        }
        /* Style for the contenteditable fields to give user feedback */
        [contenteditable]:focus {
            outline: none;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        [contenteditable] {
            cursor: text;
            user-select: text; /* Allow text selection inside editable fields */
        }
        /* CSS to create placeholder text for the name field */
        [data-placeholder]:empty::before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.6); /* Lighter color for hint text */
            pointer-events: none; /* Allow clicks to focus the element */
        }
        /* Visual feedback for the item being dragged */
        .dragging {
            opacity: 0.5;
            border: 2px dashed #60a5fa; /* A blue dash to stand out */
        }
        /* Make items draggable and add base transition */
        .draggable {
            cursor: grab;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative; 
            background-size: cover;
            background-position: center;
        }
        .draggable:active {
            cursor: grabbing;
        }
        /* Apply hover effect ONLY to non-highlighted items */
        .draggable:not(.highlighted):hover {
            transform: translateY(-4px);
        }

        /* --- Animation for the Highlight --- */
        @keyframes pulse-border {
            0% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.3);
            }
            100% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.7);
            }
        }

        /* --- New Animation for Pop-in Effect --- */
        @keyframes pop-in {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .pop-in-animation {
            animation: pop-in 0.3s ease-out forwards;
        }

        /* Style for the highlighted/selected item */
        .highlighted {
            transform: scale(1.05) translateY(-8px); /* Slightly larger and more lifted */
            animation: pulse-border 1.5s infinite; /* Apply the new animation */
        }
        
        /* New style for highlighting selected statuses in the modal */
        .symbol-selected {
            background-color: #dbeafe; /* A light blue background */
            border: 2px solid #60a5fa; /* A slightly darker blue border */
        }

        /* Style for the drag-to-select box */
        #selection-box {
            position: absolute;
            border: 2px solid #60a5fa;
            background-color: rgba(59, 130, 246, 0.2);
            pointer-events: none; /* So it doesn't interfere with mouse events */
            z-index: 9999;
        }

        /* Style for the custom color context menu */
        #context-menu {
            position: absolute;
            z-index: 10000;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 8px;
            width: 200px;
        }
        
        /* Add a text shadow for readability over any background */
        .text-readable {
            text-shadow: 0 1px 3px rgba(0,0,0,0.6);
        }
        
        /* Styles for the Notes Modal's rich text editor */
        #notes-content-editable:focus {
            outline: 2px solid #3b82f6; /* Blue outline on focus */
        }
        #notes-content-editable ul {
            list-style: disc;
            margin-left: 20px;
        }
        #notes-content-editable ol {
            list-style: decimal;
            margin-left: 20px;
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- This div is for the drag-to-select feature -->
    <div id="selection-box" style="display: none;"></div>
    
    <!-- Custom context menu for changing colors and images -->
    <div id="context-menu" class="hidden">
        <div class="space-y-2">
            <div>
                <label class="block text-sm font-medium text-gray-700">Image URL</label>
                <div class="mt-1 flex rounded-md shadow-sm">
                    <input type="text" id="image-url-input" class="focus:ring-indigo-500 focus:border-indigo-500 flex-1 block w-full rounded-none rounded-l-md sm:text-sm border-gray-300 p-1">
                    <button id="apply-url-btn" class="inline-flex items-center px-3 rounded-r-md border border-l-0 border-gray-300 bg-gray-50 text-gray-500 text-sm">Apply</button>
                </div>
            </div>
            <div>
                <label for="image-file-input" class="block text-sm font-medium text-gray-700">Or Upload File</label>
                <input type="file" id="image-file-input" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100"/>
            </div>
            <div class="border-t border-gray-200 pt-2">
                 <p class="text-sm font-medium text-gray-700 mb-1">Color</p>
                 <div id="color-grid" class="grid grid-cols-6 gap-2">
                    <!-- Color swatches will be populated here by JavaScript -->
                </div>
            </div>
        </div>
    </div>


    <!-- Main container for the scene -->
    <div class="w-full max-w-6xl mx-auto px-4 py-8">

        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Vick's Initiative Tracker</h1>

        <!-- Container for the elements, now a wrapping flex container -->
        <div id="shelf-items" class="flex flex-wrap justify-center items-start gap-4 min-h-80 p-4 bg-white rounded-lg shadow-inner">
            
            <!-- The Black Bar / Turn Marker is loaded dynamically -->

            <!-- Elements will be populated by JavaScript -->
        </div>

        <!-- Button Container -->
        <div class="mt-8 text-center space-y-4">
            <div class="space-x-4">
                <button id="move-item-btn" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200">
                    Next Turn (SPACE)
                </button>
                 <button id="last-turn-btn" class="bg-amber-500 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-amber-600 focus:outline-none focus:ring-4 focus:ring-amber-300 transition-all duration-200">
                    Last Turn (BACKSPACE)
                </button>
                <button id="add-item-btn" class="bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-200">
                    Add Character (A)
                </button>
            </div>
            <!-- Second row of buttons for actions on highlighted items -->
            <div id="action-buttons" class="space-x-4">
                <button id="remove-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Remove (DELETE)
                </button>
                <button id="copy-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Copy (C)
                </button>
                <button id="add-status-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Add Status (S)
                </button>
                <button id="clear-statuses-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Clear Statuses (X)
                </button>
                <button id="notes-btn" class="bg-gray-400 text-white font-bold py-2 px-5 rounded-lg shadow-md transition-all duration-200 cursor-not-allowed opacity-50" disabled>
                    Notes (N)
                </button>
            </div>
            <!-- New row for clear all data and other toggle buttons -->
            <div class="mt-4 space-x-4">
                <button id="hide-hp-btn" class="bg-gray-600 text-white font-bold py-2 px-5 rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-300 transition-all duration-200">
                    Hide HP
                </button>
                <button id="clear-all-data-btn" class="bg-red-800 text-white font-bold py-2 px-5 rounded-lg shadow-md hover:bg-red-900 focus:outline-none focus:ring-4 focus:ring-red-300 transition-all duration-200">
                    Clear All Data
                </button>
            </div>
        </div>
    </div>

    <!-- Status Symbol Modal -->
    <div id="status-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-800">Select a Status Effect</h2>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
            </div>
            <div id="symbol-grid" class="grid grid-cols-5 gap-4">
                <!-- Symbols will be populated here by JavaScript -->
            </div>
        </div>
    </div>
    
    <!-- Notes Modal -->
    <div id="notes-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-2xl h-full max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 id="notes-title" class="text-xl font-bold text-gray-800">Notes for...</h2>
                <button id="close-notes-modal-btn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-red-600 focus:outline-none">Close</button>
            </div>
            <div id="notes-content-editable" contenteditable="true" class="flex-grow overflow-y-auto p-4 border border-gray-300 rounded-md bg-gray-50">
                <!-- Rich text content goes here -->
            </div>
        </div>
    </div>


    <!-- JavaScript Logic -->
    <script>
        // Get the buttons and containers
        const lastTurnButton = document.getElementById('last-turn-btn');
        const moveButton = document.getElementById('move-item-btn');
        const addButton = document.getElementById('add-item-btn');
        const removeButton = document.getElementById('remove-btn');
        const copyButton = document.getElementById('copy-btn');
        const addStatusButton = document.getElementById('add-status-btn');
        const clearStatusesButton = document.getElementById('clear-statuses-btn');
        const shelf = document.getElementById('shelf-items');
        const statusModal = document.getElementById('status-modal');
        const closeModalButton = document.getElementById('close-modal-btn');
        const symbolGrid = document.getElementById('symbol-grid');
        const selectionBox = document.getElementById('selection-box');
        const contextMenu = document.getElementById('context-menu');
        const colorGrid = document.getElementById('color-grid');
        const imageUrlInput = document.getElementById('image-url-input');
        const applyUrlButton = document.getElementById('apply-url-btn');
        const imageFileInput = document.getElementById('image-file-input');
        const clearAllDataButton = document.getElementById('clear-all-data-btn');
        const notesButton = document.getElementById('notes-btn');
        const notesModal = document.getElementById('notes-modal');
        const closeNotesModalButton = document.getElementById('close-notes-modal-btn');
        const notesTitle = document.getElementById('notes-title');
        const notesContentEditable = document.getElementById('notes-content-editable');
        const hideHpButton = document.getElementById('hide-hp-btn');


        // --- Data ---
        const colorPalette = [
            'bg-red-500', 'bg-orange-500', 'bg-amber-500', 'bg-yellow-500', 'bg-lime-500', 'bg-green-500', 
            'bg-emerald-500', 'bg-teal-500', 'bg-cyan-500', 'bg-sky-500', 'bg-blue-500', 'bg-indigo-500',
            'bg-violet-500', 'bg-purple-500', 'bg-fuchsia-500', 'bg-pink-500', 'bg-rose-500', 'bg-slate-500'
        ];
        let colorIndex = 0; // To cycle through colors for new characters
        let isHpHidden = false; // To track HP visibility state
        
        const statusSymbols = ['☠️', '🔥', '❄️', '⚡️', '🛡️', '⚔️', '❤️‍🩹', '😵', '🤢', '❓', '💪', '🎯'];

        // --- IndexedDB Setup (Still used for images) ---
        let db;
        const DB_NAME = 'initiativeTrackerDB';
        const DB_VERSION = 2; 
        const IMAGE_STORE_NAME = 'images';

        function openIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    if (db.objectStoreNames.contains(IMAGE_STORE_NAME)) {
                        db.deleteObjectStore(IMAGE_STORE_NAME);
                    }
                    db.createObjectStore(IMAGE_STORE_NAME, { keyPath: 'id' });
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('IndexedDB opened successfully');
                    resolve(db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        async function saveImageToIndexedDB(id, blob) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.put({ id: id, blob: blob });

                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error("Failed to put image in IndexedDB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function loadImageFromIndexedDB(id) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readonly');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.get(id);

                request.onsuccess = (event) => resolve(event.target.result ? event.target.result.blob : null);
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        async function deleteImageFromIndexedDB(id) {
            if (!db) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                const request = store.delete(id);

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.errorCode);
            });
        }

        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        }


        // --- LocalStorage Persistence ---
        function saveState() {
            try {
                const order = [];
                const currentIds = new Set();
                
                Array.from(shelf.children).forEach(item => {
                    const id = item.id;
                    order.push(id);
                    currentIds.add(id);

                    let itemData;
                    if (item.classList.contains('character-card')) {
                        const nameSpan = item.querySelector('.font-bold.text-lg');
                        const currentHpSpan = item.querySelector('.current-hp');
                        const totalHpSpan = item.querySelector('.total-hp');
                        const statusContainer = item.querySelector('.status-container');
                        const statuses = Array.from(statusContainer.querySelectorAll('span')).map(s => s.textContent);
                        
                        itemData = {
                            type: 'character',
                            name: nameSpan ? nameSpan.textContent.trim() : '',
                            hp: currentHpSpan ? currentHpSpan.textContent.trim() : '',
                            totalHp: totalHpSpan ? totalHpSpan.textContent.trim() : '',
                            statuses: statuses,
                            bgColor: Array.from(item.classList).find(cls => colorPalette.includes(cls)) || '',
                            bgImageKey: item.dataset.bgImageKey || '',
                            notes: item.dataset.notes || ''
                        };
                    } else if (item.id.startsWith('turn-marker')) {
                        const turnCounter = item.querySelector('.turn-counter');
                        itemData = {
                            type: 'turnMarker',
                            turn: turnCounter ? turnCounter.textContent.trim() : '1'
                        };
                    }
                    localStorage.setItem(id, JSON.stringify(itemData));
                });

                localStorage.setItem('initiativeOrder', JSON.stringify(order));
                localStorage.setItem('isHpHidden', JSON.stringify(isHpHidden));
                
                // Cleanup orphaned items
                const savedOrder = JSON.parse(localStorage.getItem('initiativeOrder')) || [];
                const savedIdSet = new Set(savedOrder);

                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key !== 'initiativeOrder' && key !== 'isHpHidden' && !savedIdSet.has(key)) {
                        localStorage.removeItem(key);
                        i--; // Adjust index after removal
                    }
                }
                console.log('State saved to localStorage.');
            } catch (e) {
                console.error("Failed to save state to localStorage:", e);
            }
        }
        
        async function loadState() {
            const orderJSON = localStorage.getItem('initiativeOrder');
            if (!orderJSON) return false;

            try {
                const order = JSON.parse(orderJSON);
                shelf.innerHTML = ''; 
                colorIndex = 0; // Reset color index on load

                const itemPromises = order.map(async (id) => {
                    const itemJSON = localStorage.getItem(id);
                    if (!itemJSON) return null;
                    
                    const itemData = JSON.parse(itemJSON);
                    
                    let bgImageUrl = '';
                    if (itemData.bgImageKey && itemData.bgImageKey.startsWith('indexeddb://')) {
                        const blob = await loadImageFromIndexedDB(itemData.bgImageKey).catch(e => console.error(e));
                        if(blob) bgImageUrl = URL.createObjectURL(blob);
                    } else if (itemData.bgImageKey) {
                        bgImageUrl = itemData.bgImageKey;
                    }

                    itemData.bgImageUrl = bgImageUrl; // Attach the resolved URL
                    return { id, data: itemData };
                });

                const loadedItems = await Promise.all(itemPromises);

                loadedItems.forEach(item => {
                    if (!item) return;
                    const { id, data } = item;
                    if (data.type === 'turnMarker') {
                        createTurnMarker(id, data.turn);
                    } else if (data.type === 'character') {
                        const options = {
                            id: id,
                            backgroundColorClass: data.bgColor,
                            backgroundImage: data.bgImageUrl,
                            bgImageKey: data.bgImageKey
                        };
                        createCharacter(
                            data.name, 
                            data.hp, 
                            data.totalHp || data.hp, // Fallback for old data
                            data.statuses,
                            data.notes, 
                            options
                        );
                    }
                });

                console.log('State loaded from localStorage.');
                updateActionButtonsState();
                return true;
            } catch (e) {
                console.error("Failed to load or parse state from localStorage:", e);
                return false;
            }
        }

        // --- Core Functions for Item States ---

        function updateActionButtonsState() {
            const selectedItems = document.querySelectorAll('.highlighted');
            const buttonsToUpdate = [removeButton, copyButton, addStatusButton, clearStatusesButton, notesButton];
            
            if (selectedItems.length > 0) {
                buttonsToUpdate.forEach(button => {
                    button.disabled = false;
                    button.classList.remove('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                });
                removeButton.classList.add('bg-red-600', 'hover:bg-red-700', 'focus:ring-4', 'focus:ring-red-300');
                copyButton.classList.add('bg-teal-600', 'hover:bg-teal-700', 'focus:ring-4', 'focus:ring-teal-300');
                addStatusButton.classList.add('bg-purple-600', 'hover:bg-purple-700', 'focus:ring-4', 'focus:ring-purple-300');
                clearStatusesButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-4', 'focus:ring-yellow-300');
                notesButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700', 'focus:ring-4', 'focus:ring-indigo-300');
            } else {
                buttonsToUpdate.forEach(button => {
                    button.disabled = true;
                    button.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-50');
                    button.classList.remove(
                        'bg-red-600', 'hover:bg-red-700', 'focus:ring-red-300',
                        'bg-teal-600', 'hover:bg-teal-700', 'focus:ring-teal-300',
                        'bg-purple-600', 'hover:bg-purple-700', 'focus:ring-purple-300',
                        'bg-yellow-500', 'hover:bg-yellow-600', 'focus:ring-yellow-300',
                        'bg-indigo-600', 'hover:bg-indigo-700', 'focus:ring-indigo-300',
                        'focus:ring-4'
                    );
                });
            }
        }

        function initializeDraggable(item) {
            item.setAttribute('draggable', true);
            item.addEventListener('dragstart', () => {
                if (!item.classList.contains('highlighted')) {
                    document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                    item.classList.add('highlighted');
                }
                setTimeout(() => item.classList.add('dragging'), 0)
            });
            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
                saveState(); 
            });
        }

        function initializeSelectable(item) {
             if (!item.classList.contains('character-card')) return;
            item.addEventListener('click', (event) => {
                if (event.target.getAttribute('contenteditable') === 'true' || event.target.closest('.notes-indicator')) return;
                
                if (event.shiftKey) {
                    item.classList.toggle('highlighted');
                } else {
                    const isAlreadySelected = item.classList.contains('highlighted');
                    const selectedCount = document.querySelectorAll('.highlighted').length;

                    if (isAlreadySelected && selectedCount > 1) {
                         return;
                    }
                    
                    document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                    if (!isAlreadySelected) item.classList.add('highlighted');
                }
                updateActionButtonsState();
            });
        }

        function initializeHpField(hpSpan) {
            const parentCard = hpSpan.closest('.character-card');
            hpSpan.addEventListener('focus', () => hpSpan.dataset.originalHp = hpSpan.textContent.trim());

            const resolveHp = () => {
                const expression = hpSpan.textContent.trim();
                let newHp;
                try {
                    newHp = new Function('return (' + expression.replace(/[^-()\d/*+.]/g, '') + ')')();
                } catch (e) { newHp = parseInt(expression, 10) || 0; }
                hpSpan.textContent = Math.round(newHp);
                updateCharacterHpDisplay(parentCard); // Update damage display after edit
                saveState(); 
            };
            
            hpSpan.addEventListener('blur', resolveHp);
            hpSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); resolveHp(); hpSpan.blur(); } 
                else if (e.key === 'Escape') {
                    hpSpan.textContent = hpSpan.dataset.originalHp;
                    updateCharacterHpDisplay(parentCard); // Update damage display after cancel
                    hpSpan.blur();
                }
            });

            const nameSpan = hpSpan.closest('.draggable').querySelector('.font-bold.text-lg');
            if (nameSpan) {
                nameSpan.addEventListener('blur', saveState);
                nameSpan.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); nameSpan.blur(); }});
            }
        }
        
        function initializeContextMenu(item) {
            item.addEventListener('contextmenu', e => {
                e.preventDefault();
                if (!item.classList.contains('character-card')) return;

                if (!item.classList.contains('highlighted')) {
                    document.querySelectorAll('.highlighted').forEach(el => el.classList.remove('highlighted'));
                    item.classList.add('highlighted');
                    updateActionButtonsState();
                }

                contextMenu.style.left = `${e.clientX}px`;
                contextMenu.style.top = `${e.clientY}px`;
                contextMenu.classList.remove('hidden');
            });
        }

        shelf.addEventListener('dragover', e => {
            e.preventDefault();
            const draggingItem = document.querySelector('.dragging');
            if (!draggingItem) return;

            const afterElement = getDragAfterElement(shelf, e.clientX, e.clientY);
            if (afterElement == null) shelf.appendChild(draggingItem);
            else shelf.insertBefore(draggingItem, afterElement);
        });

        function getDragAfterElement(container, x, y) {
            const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                if (y > box.top && y < box.bottom) {
                    const offset = x - box.left - box.width / 2;
                    if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
                }
                return closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // --- HP Display Logic ---
        function updateCharacterHpDisplay(characterElement) {
            const standardView = characterElement.querySelector('.hp-standard-view');
            const damageView = characterElement.querySelector('.hp-damage-view');
            const damageText = characterElement.querySelector('.damage-text');
            const hpHeader = characterElement.querySelector('.hp-header');

            if (!standardView || !damageView || !damageText || !hpHeader) return;

            if (isHpHidden) {
                standardView.classList.add('hidden');
                hpHeader.classList.add('hidden');

                const currentHp = parseInt(characterElement.querySelector('.current-hp').textContent, 10) || 0;
                const totalHp = parseInt(characterElement.querySelector('.total-hp').textContent, 10) || 0;
                const damage = totalHp - currentHp;

                if (damage > 0) {
                    damageText.textContent = `${damage} damage`;
                    damageView.classList.remove('hidden');
                } else {
                    damageText.textContent = '';
                    damageView.classList.add('hidden'); // Hide if no damage
                }
            } else {
                standardView.classList.remove('hidden');
                damageView.classList.add('hidden');
                hpHeader.classList.remove('hidden');
            }
        }

        function updateAllCharacterHpDisplay() {
            document.querySelectorAll('.character-card').forEach(updateCharacterHpDisplay);
        }

        function createCharacter(name, hp, totalHp, statuses = [], notes = '', options = {}) {
            const { 
                id = null, insertionElement = null, backgroundColorClass = null, 
                backgroundImage = '', bgImageKey = ''
            } = options;

            const newItem = document.createElement('div');
            newItem.id = id || `char-${crypto.randomUUID()}`;
            newItem.classList.add('character-card');

            const newColor = backgroundColorClass || colorPalette[colorIndex++ % colorPalette.length];
            newItem.className = `draggable ${newColor} rounded-md w-32 min-h-56 shadow-lg flex flex-col justify-between p-2 text-white character-card`;
            
            newItem.dataset.notes = notes;
            newItem.dataset.bgImageKey = bgImageKey;
            
            if (backgroundImage) newItem.style.backgroundImage = `url('${backgroundImage}')`;

            const nameContent = name || '';
            const namePlaceholder = name ? '' : 'data-placeholder="Name"';

            newItem.innerHTML = `
                <div class="flex flex-col items-center flex-shrink-0">
                    <span contenteditable="true" class="font-bold text-lg p-1 text-center text-readable" ${namePlaceholder}>${nameContent}</span>
                    <div class="flex flex-col items-center mt-2">
                        <span class="hp-header text-xs font-semibold text-white/80 select-none text-readable">HP</span>
                        <div class="hp-display-container">
                            <div class="hp-standard-view flex items-baseline justify-center">
                                <span contenteditable="true" class="current-hp text-2xl font-mono p-1 text-readable">${hp}</span>
                                <span class="mx-1 text-white/80">/</span>
                                <span contenteditable="true" class="total-hp text-2xl font-mono p-1 text-readable">${totalHp}</span>
                            </div>
                            <div class="hp-damage-view hidden text-center h-9 flex items-center justify-center">
                                <span class="damage-text text-lg font-semibold p-1 text-readable text-red-300"></span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="status-container w-full flex-grow mt-2 p-1 flex flex-wrap items-center justify-center content-start gap-2"></div>
                <div class="absolute bottom-1 right-1 notes-indicator text-lg" style="display: none;">📝</div>
            `;

            const statusContainer = newItem.querySelector('.status-container');
            statuses.forEach(symbol => {
                 const statusIcon = document.createElement('span');
                 statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-default text-readable";
                 statusIcon.textContent = symbol;
                 statusContainer.appendChild(statusIcon);
            });
            
            updateNotesIndicator(newItem);
            initializeHpField(newItem.querySelector('.current-hp'));
            initializeHpField(newItem.querySelector('.total-hp'));
            updateCharacterHpDisplay(newItem); // Apply current HP visibility state
            initializeDraggable(newItem);
            initializeSelectable(newItem);
            initializeContextMenu(newItem);
            
            if(insertionElement) insertionElement.after(newItem);
            else shelf.appendChild(newItem);

            if (!options.id) { // Only animate and save if it's a newly created item
                newItem.classList.add('pop-in-animation');
                newItem.addEventListener('animationend', () => newItem.classList.remove('pop-in-animation'), { once: true });
                saveState();
            }
            return newItem; 
        }
        
        function createTurnMarker(id = null, turn = '1') {
            const turnMarker = document.createElement('div');
            turnMarker.id = id || `turn-marker-${crypto.randomUUID()}`;
            turnMarker.className = 'draggable flex items-end h-56';

            turnMarker.innerHTML = `
                <div class="w-4 h-full bg-black rounded-l-lg"></div>
                <div class="bg-black text-white p-2 rounded-r-lg shadow-lg">
                    <div class="text-xs font-semibold uppercase text-white/80 select-none">Turn</div>
                    <span class="turn-counter text-2xl font-mono" contenteditable="true">${turn}</span>
                </div>
            `;
            
            initializeDraggable(turnMarker);
            
            const turnCounterSpan = turnMarker.querySelector('.turn-counter');
            turnCounterSpan.addEventListener('blur', saveState);
            turnCounterSpan.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter') { e.preventDefault(); turnCounterSpan.blur(); }
            });

            shelf.appendChild(turnMarker);
            if(!id) saveState();
        }

        // --- Modal & Menu Logic ---
        function populateSymbolModal(selectedItems) {
            symbolGrid.innerHTML = '';
            statusSymbols.forEach((symbol) => {
                const symbolButton = document.createElement('button');
                symbolButton.className = "relative text-3xl p-4 rounded-lg hover:bg-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500";
                
                const allHaveStatus = Array.from(selectedItems).every(item => Array.from(item.querySelectorAll('.status-container span')).some(s => s.textContent === symbol));
                if (allHaveStatus) symbolButton.classList.add('symbol-selected');

                symbolButton.innerHTML = `<span class="pointer-events-none">${symbol}</span><span class="absolute bottom-1 right-1 text-xs font-mono bg-gray-600 text-white rounded-sm px-1.5 py-0.5 pointer-events-none">${(statusSymbols.indexOf(symbol) + 1) % 10}</span>`;
                
                symbolButton.addEventListener('click', () => {
                    selectedItems.forEach(item => {
                        const statusContainer = item.querySelector('.status-container');
                        if (allHaveStatus) {
                            statusContainer.querySelectorAll('span').forEach(icon => {
                                if (icon.textContent === symbol) icon.remove();
                            });
                        } else if (!Array.from(statusContainer.querySelectorAll('span')).some(s => s.textContent === symbol)) {
                            const statusIcon = document.createElement('span');
                            statusIcon.className = "text-xl bg-black bg-opacity-25 p-1 rounded-md cursor-default text-readable";
                            statusIcon.textContent = symbol;
                            statusContainer.appendChild(statusIcon);
                        }
                    });
                    populateSymbolModal(selectedItems);
                    saveState(); 
                });
                symbolGrid.appendChild(symbolButton);
            });
        }
        
        function populateColorMenu() {
            colorGrid.innerHTML = '';
            colorPalette.forEach(color => {
                const swatch = document.createElement('button');
                swatch.className = `w-8 h-8 rounded-full ${color} border-2 border-white/50 hover:scale-110 transition-transform`;
                swatch.addEventListener('click', () => {
                    document.querySelectorAll('.highlighted').forEach(item => {
                        item.style.backgroundImage = ''; 
                        item.dataset.bgImageKey = '';
                        item.classList.remove(...colorPalette);
                        item.classList.add(color);
                    });
                    contextMenu.classList.add('hidden');
                    saveState(); 
                });
                colorGrid.appendChild(swatch);
            });
        }
        
        function handleStatusModalToggle() {
             if (!statusModal.classList.contains('hidden')) {
                statusModal.classList.add('hidden');
            } else if (!addStatusButton.disabled) {
                const selectedItems = document.querySelectorAll('.highlighted');
                if (selectedItems.length > 0) {
                    populateSymbolModal(selectedItems);
                    statusModal.classList.remove('hidden');
                }
            }
        }
        
        function updateNotesIndicator(item) {
            const indicator = item.querySelector('.notes-indicator');
            if (indicator) indicator.style.display = item.dataset.notes ? 'block' : 'none';
        }

        function openNotesModal() {
            const selectedItems = document.querySelectorAll('.highlighted');
            if (selectedItems.length === 0) return;
            
            const firstItem = selectedItems[0];
            const name = firstItem.querySelector('.font-bold.text-lg').textContent.trim() || 'Unnamed Character';
            notesTitle.textContent = `Notes for ${name}`;
            if (selectedItems.length > 1) notesTitle.textContent += ` (+${selectedItems.length - 1} others)`;
            
            notesContentEditable.innerHTML = firstItem.dataset.notes || '';
            notesModal.classList.remove('hidden');
        }

        function closeNotesModal() {
            const newNotes = notesContentEditable.innerHTML;
            document.querySelectorAll('.highlighted').forEach(item => {
                item.dataset.notes = newNotes;
                updateNotesIndicator(item);
            });
            notesModal.classList.add('hidden');
            saveState();
        }

        notesButton.addEventListener('click', openNotesModal);
        closeNotesModalButton.addEventListener('click', closeNotesModal);
        addStatusButton.addEventListener('click', handleStatusModalToggle);
        closeModalButton.addEventListener('click', () => statusModal.classList.add('hidden'));
        statusModal.addEventListener('click', (e) => { if (e.target === statusModal) statusModal.classList.add('hidden'); });
        
        applyUrlButton.addEventListener('click', () => {
            const url = imageUrlInput.value.trim();
            if (url) {
                document.querySelectorAll('.highlighted').forEach(item => {
                    item.style.backgroundImage = `url('${url}')`;
                    item.dataset.bgImageKey = url;
                });
                saveState();
            }
            contextMenu.classList.add('hidden');
            imageUrlInput.value = '';
        });

        imageFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                const imageId = `indexeddb://${crypto.randomUUID()}`;
                await saveImageToIndexedDB(imageId, file);
                const objectUrl = URL.createObjectURL(file);
                document.querySelectorAll('.highlighted').forEach(item => {
                    item.style.backgroundImage = `url('${objectUrl}')`;
                    item.dataset.bgImageKey = imageId;
                });
                saveState();
            }
            contextMenu.classList.add('hidden');
            e.target.value = null; 
        });

        // --- Button & Keyboard Logic ---
        lastTurnButton.addEventListener('click', () => {
            const lastItem = shelf.querySelector('.draggable:last-child');
            if(lastItem) {
                shelf.insertBefore(lastItem, shelf.firstChild);
                if (lastItem.id.startsWith('turn-marker')) {
                    const counter = lastItem.querySelector('.turn-counter');
                    let currentTurn = parseInt(counter.textContent, 10);
                    if (!isNaN(currentTurn) && currentTurn > 1) counter.textContent = currentTurn - 1;
                }
                saveState(); 
            }
        });

        moveButton.addEventListener('click', () => {
            const firstItem = shelf.querySelector('.draggable');
            if(firstItem) {
                shelf.appendChild(firstItem);
                if (firstItem.id.startsWith('turn-marker')) {
                    const counter = firstItem.querySelector('.turn-counter');
                    let currentTurn = parseInt(counter.textContent, 10);
                    counter.textContent = isNaN(currentTurn) ? 1 : currentTurn + 1;
                }
                saveState();
            }
        });

        addButton.addEventListener('click', () => createCharacter('', 10, 10, [], '', {}));

        removeButton.addEventListener('click', () => {
            document.querySelectorAll('.highlighted').forEach(item => {
                localStorage.removeItem(item.id);
                item.remove();
            });
            updateActionButtonsState();
            saveState(); 
        });

        copyButton.addEventListener('click', () => {
            const originals = document.querySelectorAll('.highlighted');
            if (originals.length === 0) return;

            originals.forEach(original => {
                const originalName = original.querySelector('.font-bold.text-lg').textContent.trim();
                
                const nameMatch = originalName.match(/(.+) (\d+)$/);
                const baseName = nameMatch ? nameMatch[1] : originalName;

                const allCharacters = Array.from(shelf.querySelectorAll('.character-card'));
                let highestNumber = 0;
                let insertionTarget = original;

                allCharacters.forEach(char => {
                    const charName = char.querySelector('.font-bold.text-lg').textContent.trim();
                    if (charName.startsWith(baseName)) {
                        const charMatch = charName.match(/(\d+)$/);
                        if (charMatch) {
                            const currentNum = parseInt(charMatch[1], 10);
                            if (currentNum > highestNumber) {
                                highestNumber = currentNum;
                                insertionTarget = char;
                            }
                        } else if (highestNumber === 0) {
                            highestNumber = 1;
                            insertionTarget = char;
                        }
                    }
                });

                const newNumber = highestNumber + 1;
                const newName = `${baseName} ${newNumber}`;
                
                const hp = original.querySelector('.current-hp').textContent.trim();
                const totalHp = original.querySelector('.total-hp').textContent.trim();
                const statuses = Array.from(original.querySelectorAll('.status-container span')).map(s => s.textContent);
                const notes = original.dataset.notes || '';
                const bgImageKey = original.dataset.bgImageKey || '';
                const bgStyle = original.style.backgroundImage;

                const options = { 
                    insertionElement: insertionTarget,
                    backgroundImage: bgStyle ? bgStyle.substring(5, bgStyle.length - 2).replace(/['"]/g, '') : '',
                    bgImageKey: bgImageKey
                };
                createCharacter(newName, hp, totalHp, statuses, notes, options);
            });
            saveState();
        });

        hideHpButton.addEventListener('click', () => {
            isHpHidden = !isHpHidden;
            updateAllCharacterHpDisplay();
            if (isHpHidden) {
                hideHpButton.textContent = 'Show HP';
                hideHpButton.classList.remove('bg-gray-600', 'hover:bg-gray-700', 'focus:ring-gray-300');
                hideHpButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700', 'focus:ring-cyan-300');
            } else {
                hideHpButton.textContent = 'Hide HP';
                hideHpButton.classList.add('bg-gray-600', 'hover:bg-gray-700', 'focus:ring-gray-300');
                hideHpButton.classList.remove('bg-cyan-600', 'hover:bg-cyan-700', 'focus:ring-cyan-300');
            }
            saveState();
        });

        clearStatusesButton.addEventListener('click', () => {
             document.querySelectorAll('.highlighted .status-container').forEach(c => c.innerHTML = '');
             saveState(); 
        });

        clearAllDataButton.addEventListener('click', async () => { 
            localStorage.clear();
            if (db) {
                const transaction = db.transaction([IMAGE_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(IMAGE_STORE_NAME);
                store.clear();
            }
            shelf.innerHTML = ''; 
            await initializeApp();
        });

        let isSelecting = false;
        let startX, startY;
        shelf.addEventListener('mousedown', (e) => {
            if (e.target.closest('.draggable')) return;
            e.preventDefault();
            isSelecting = true;
            startX = e.clientX; startY = e.clientY;
            Object.assign(selectionBox.style, { left: `${startX}px`, top: `${startY}px`, width: '0px', height: '0px', display: 'block' });
            if (!e.shiftKey) {
                document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                updateActionButtonsState();
            }
        });
        window.addEventListener('mousemove', (e) => {
            if (!isSelecting) return;
            e.preventDefault();
            const currentX = e.clientX, currentY = e.clientY;
            const width = Math.abs(currentX - startX), height = Math.abs(currentY - startY);
            const left = Math.min(currentX, startX), top = Math.min(currentY, startY);
            Object.assign(selectionBox.style, { width: `${width}px`, height: `${height}px`, left: `${left}px`, top: `${top}px` });
            const boxRect = selectionBox.getBoundingClientRect();
            document.querySelectorAll('.draggable.character-card').forEach(item => {
                const itemRect = item.getBoundingClientRect();
                const isIntersecting = !(boxRect.right < itemRect.left || boxRect.left > itemRect.right || boxRect.bottom < itemRect.top || boxRect.top > itemRect.bottom);
                if (isIntersecting) item.classList.add('highlighted');
                else if(!e.shiftKey) item.classList.remove('highlighted');
            });
            updateActionButtonsState();
        });
        window.addEventListener('mouseup', () => {
            if (isSelecting) {
                isSelecting = false;
                selectionBox.style.display = 'none';
            }
        });
        
        document.addEventListener('keydown', (event) => {
            const isNotesModalOpen = !notesModal.classList.contains('hidden');
            const isStatusModalOpen = !statusModal.classList.contains('hidden');
            const isContextMenuOpen = !contextMenu.classList.contains('hidden');
            const activeElementIsEditable = document.activeElement.getAttribute('contenteditable') === 'true' || document.activeElement === imageUrlInput;

            if (event.key === 'Escape') {
                if (isNotesModalOpen) return closeNotesModal();
                if (isStatusModalOpen) return statusModal.classList.add('hidden');
                if (isContextMenuOpen) return contextMenu.classList.add('hidden');
                document.querySelectorAll('.draggable.highlighted').forEach(el => el.classList.remove('highlighted'));
                updateActionButtonsState();
                return;
            }
            
            if (isNotesModalOpen && event.code === 'KeyN' && document.activeElement !== notesContentEditable) {
                event.preventDefault();
                return closeNotesModal();
            }
            if (isNotesModalOpen || isContextMenuOpen || activeElementIsEditable) return;
            
            if (isStatusModalOpen) {
                if (event.code.startsWith('Digit')) {
                    event.preventDefault();
                    const keyNumber = event.code === 'Digit0' ? 9 : parseInt(event.code.slice(-1)) - 1;
                    if (symbolGrid.children[keyNumber]) symbolGrid.children[keyNumber].click();
                }
                return; 
            }
            
            switch (event.code) {
                case 'Space': event.preventDefault(); moveButton.click(); break;
                case 'Backspace': event.preventDefault(); lastTurnButton.click(); break;
                case 'KeyA': event.preventDefault(); addButton.click(); break;
                case 'KeyS': event.preventDefault(); if (!addStatusButton.disabled) handleStatusModalToggle(); break;
                case 'KeyC': event.preventDefault(); if (!copyButton.disabled) copyButton.click(); break;
                case 'KeyX': event.preventDefault(); if (!clearStatusesButton.disabled) clearStatusesButton.click(); break;
                case 'KeyN': event.preventDefault(); if (!notesButton.disabled) openNotesModal(); break;
                case 'Delete': event.preventDefault(); if (!removeButton.disabled) removeButton.click(); break;
            }
        });
        
        window.addEventListener('click', (e) => {
            if (!contextMenu.classList.contains('hidden') && !contextMenu.contains(e.target) && !e.target.closest('.draggable')) {
                contextMenu.classList.add('hidden');
            }
        });

        function initializeDefaultScene() {
            localStorage.clear();
            colorIndex = 0; // Ensure colors start from the beginning
            const goblinImageUrl = 'https://www.dndbeyond.com/avatars/thumbnails/30783/955/1000/1000/638062024584880857.png';
            const goblinNotes = `<p><strong>Goblin</strong><br><em>Small Humanoid (Goblinoid), Neutral Evil</em></p><hr><p><strong>Armor Class</strong> 15 (leather armor, shield)<br><strong>Hit Points</strong> 7 (2d6)<br><strong>Speed</strong> 30 ft.</p><hr><p><strong>STR</strong> 8 (-1) | <strong>DEX</strong> 14 (+2) | <strong>CON</strong> 10 (+0) | <strong>INT</strong> 10 (+0) | <strong>WIS</strong> 8 (-1) | <strong>CHA</strong> 8 (-1)</p><hr><p><strong>Skills</strong> Stealth +6<br><strong>Senses</strong> Darkvision 60 ft., Passive Perception 9<br><strong>Languages</strong> Common, Goblin<br><strong>Challenge</strong> 1/4 (50 XP) | <strong>Proficiency Bonus</strong> +2</p><hr><p><strong><em>Nimble Escape.</em></strong> The goblin can take the Disengage or Hide action as a bonus action on each of its turns.</p><p><strong>Actions</strong><br><strong><em>Scimitar.</em></strong> <em>Melee Weapon Attack:</em> +4 to hit, reach 5 ft., one target. <em>Hit:</em> 5 (1d6 + 2) slashing damage.<br><strong><em>Shortbow.</em></strong> <em>Ranged Weapon Attack:</em> +4 to hit, range 80/320 ft., one target. <em>Hit:</em> 5 (1d6 + 2) piercing damage.</p>`;

            createTurnMarker();
            const goblinOptions = { bgImageKey: goblinImageUrl, backgroundImage: goblinImageUrl };
            createCharacter('Goblin 1', 7, 7, [], goblinNotes, goblinOptions);
            createCharacter('Goblin 2', 7, 7, [], goblinNotes, goblinOptions);
            createCharacter('Goblin 3', 4, 7, ['❤️‍🩹'], goblinNotes, goblinOptions);
            createCharacter('Hector the Well-Endowed', 18, 18, ['⚡️'], '', {});
            saveState(); // Perform initial save
        }
        
        async function initializeApp() {
            populateColorMenu();
            await openIndexedDB();

            isHpHidden = JSON.parse(localStorage.getItem('isHpHidden')) || false;
            if (isHpHidden) {
                hideHpButton.textContent = 'Show HP';
                hideHpButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                hideHpButton.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
            }

            if (!await loadState()) {
                initializeDefaultScene();
            }
            
            updateAllCharacterHpDisplay();
        }
        
        initializeApp();

    </script>
</body>
</html>
